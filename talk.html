<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LOZEE와 대화하기</title>
  <link href="https://fonts.googleapis.com/css2?family=KoPub+World+Dotum:wght@400;700&display=swap" rel="stylesheet"/> 
<style>
  :root {
      --primary-color: #6e8efb;
      --secondary-color: #5a7edf;
      --background-color: #ffffff;
      --text-color: #333333;
      
      --gnb-bg: #354157;
      --gnb-text-color: #ffffff;
      --gnb-title-color: var(--primary-color);
      --gnb-menu-toggle-color: var(--primary-color);
      --gnb-dropdown-bg: var(--gnb-bg);
      --gnb-dropdown-text-color: var(--gnb-text-color);
      --gnb-dropdown-border-color: #4a5568;
      --gnb-dropdown-hover-bg: var(--secondary-color);

      --user-bubble-bg: var(--primary-color);
      --user-bubble-text: #ffffff;
      --ai-bubble-bg: #F5E7A1;;
      --ai-bubble-text: #333333;

      --input-area-bg: #f8f9fa;
      --chat-input-bg: #ffffff;
      --chat-input-text-color: #333333;
      --chat-input-border-color: #ced4da;
      --chat-input-placeholder-color: #777777;

      --button-bg: var(--primary-color);
      --button-text-color: #ffffff;
      --button-hover-bg: var(--secondary-color);

      --volume-meter-container-bg: #e9ecef;
      --volume-meter-level-bg: var(--primary-color);
      --meter-height: 6px;
      --meter-top-margin: 8px;

      /* #topic-area 관련 변수는 더 이상 사용되지 않을 수 있음 */
      /* --topic-button-bg: var(--primary-color); */
      /* --topic-button-text: #ffffff; */
      /* --topic-button-hover-bg: var(--secondary-color); */

      --analysis-notification-bg: #fff3cd;
      --analysis-notification-text: #856404;

      --gnb-height: 56px;
      --chat-input-area-height: 70px;
    }

    body {
      margin: 0;
      padding-top: var(--gnb-height);
      font-family: 'KoPub World Dotum', sans-serif;
      background: var(--background-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      height: 100vh;
      box-sizing: border-box;
      overflow: hidden;
    }

    #gnb {
      padding: 0 30px; /* 안전지대 30px 적용 */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: var(--gnb-height);
      background-color: var(--gnb-bg);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-sizing: border-box;
    }

    #gnb-title {
      font-size: 1.2em;
      font-weight: bold;
      color: var(--gnb-title-color);
    }

    #menu-toggle {
      background: none;
      border: none;
      color: var(--gnb-menu-toggle-color);
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #dropdown-menu {
      position: fixed;
      top: var(--gnb-height);
      right: 0;
      background-color: var(--gnb-dropdown-bg);
      border-radius: 0 0 0 8px;
      box-shadow: -3px 3px 6px rgba(0,0,0,0.2);
      width: 200px;
      z-index: 999;
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.3s ease-out;
    }

    #dropdown-menu.show {
      max-height: 300px;
    }

    #dropdown-menu a {
      display: block;
      padding: 12px 16px;
      text-decoration: none;
      color: var(--gnb-dropdown-text-color);
      border-bottom: 1px solid var(--gnb-dropdown-border-color);
      font-size: 0.95em;
    }
    #dropdown-menu a:last-child {
      border-bottom: none;
    }
    #dropdown-menu a:hover {
      background-color: var(--gnb-dropdown-hover-bg);
    }

    #meter-container {
      position: fixed;
      top: calc(var(--gnb-height) + var(--meter-top-margin));
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      max-width: 300px;
      height: var(--meter-height);
      background: var(--volume-meter-container-bg);
      border-radius: 3px;
      overflow: hidden;
      z-index: 998;
    }
    #volume-level {
      width: 0%;
      height: 100%;
      background: var(--volume-meter-level-bg);
      border-radius: 3px;
      transition: width 0.05s linear, background-color 0.05s linear;
    }
    
    #chat-window {
      flex: 1;
      padding: 16px;
      padding-top: calc(var(--meter-top-margin) + var(--meter-height) + 10px);
      padding-bottom: calc(var(--chat-input-area-height) + 10px);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-sizing: border-box;
    }
    
    #chat-window::-webkit-scrollbar { width: 8px; }
    #chat-window::-webkit-scrollbar-track { background: var(--background-color); }
    #chat-window::-webkit-scrollbar-thumb { background: #cccccc; border-radius: 4px; }
    #chat-window::-webkit-scrollbar-thumb:hover { background: #aaaaaa; }

    .bubble {
      max-width: 75%;
      padding: 10px 15px;
      border-radius: 18px;
      line-height: 1.6;
      word-break: keep-all;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .bubble.user {
      background: var(--user-bubble-bg);
      color: var(--user-bubble-text);
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .bubble.ai {
      background: var(--ai-bubble-bg);
      color: var(--ai-bubble-text);
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }

    .analysis-notification {
      align-self: center;
      background: var(--analysis-notification-bg);
      color: var(--analysis-notification-text);
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 0.9em;
      margin: 5px 0;
    }

    /* 기존 #topic-area는 새로운 UI 방식으로 대체되므로 숨김 처리 */
    #topic-area {
      display: none !important; 
    }
    /* .topic-btn, .subtopic-btn 관련 스타일도 #topic-area를 사용하지 않으면 불필요 */

    #input-area {
      padding: 0 30px; /* 안전지대 30px 적용 */
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: var(--chat-input-area-height);
      display: none; /* 초기 숨김, startChat()에서 flex로 변경 */
      align-items: center;
      gap: 8px;
      background: var(--input-area-bg);
      border-top: 1px solid #e0e0e0;
      box-sizing: border-box;
    }
    #input-area button, #input-area input {
      font-size: 1em;
      height: 44px;
      box-sizing: border-box;
    }

    #chat-input {
      flex: 1;
      padding: 10px 16px;
      border: 1px solid var(--chat-input-border-color);
      border-radius: 22px;
      outline: none;
      background-color: var(--chat-input-bg);
      color: var(--chat-input-text-color);
    }
    #chat-input::placeholder {
      color: var(--chat-input-placeholder-color);
    }

    #mic-button, #send-btn {
      width: 44px;
      min-width: 44px;
      height: 44px;
      border: none;
      border-radius: 50%;
      background: var(--button-bg);
      color: var(--button-text-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3em;
      transition: background-color 0.2s ease;
    }
    #mic-button:hover, #send-btn:hover {
      background: var(--button-hover-bg);
    }
    #mic-button.recording {
      background: #e74c3c;
    }
    #send-btn.loading {
        background:#cccccc;
        cursor:default;
    }
    
    @media (max-width: 600px) {
      #gnb { padding: 0 20px; } /* 모바일에서는 GNB 패딩 약간 줄임 */
      #input-area { padding: 0 20px; } /* 모바일에서는 입력창 패딩 약간 줄임 */
      #gnb-title { font-size: 1.1em; }
      .bubble { padding: 9px 13px; max-width: 85%; }
      #chat-input { padding: 9px 14px; }
      #mic-button, #send-btn { width: 40px; height: 40px; font-size: 1.2em;}
      #input-area { height: 65px; }
      #chat-window { padding-bottom: calc(65px + 10px); }
      /* #topic-area 관련 반응형 규칙은 더 이상 필요 없을 수 있음 */
    }

    /* 채팅창 내 선택지 컨테이너 */
    .chat-options-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 10px 0;
      align-items: flex-start;
      max-width: 80%;
      align-self: flex-start;
    }

    /* 채팅창 내 선택 버튼 */
    .chat-option-btn {
      background-color: #f1f1f1;
      color: #333333;
      border: 1px solid #dcdcdc;;
      border-radius: 12px;
      padding: 10px 15px;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 0.95em;
      transition: background-color 0.2s, transform 0.1s;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }

    .chat-option-btn:hover {
      background-color: #e9e9e9;
      transform: translateY(-1px);
    }

    .chat-option-btn.selected {
      background-color: #E4D2FD;
      color: #333;
      border-color: #c3b2e0; /* 오타 수정 */
      font-weight: bold;
    }

    .chat-option-btn:disabled {
      background-color: #f8f8f8;
      color: #aaaaaa;
      cursor: not-allowed;
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <nav id="gnb">
    <div id="gnb-title">LOZEE</div>
    <button id="menu-toggle">☰</button>
    <div id="dropdown-menu">
      <a href="mypage.html">My Page</a>
      <a href="index.html">주제 변경</a>
      <a href="analysis.html">대화 분석</a>
      <a href="journal-list.html">대화 목록</a>
    </div>
  </nav>
  <div id="meter-container"><div id="volume-level"></div></div>
  <div id="chat-window"></div>
  <div id="input-area">
    <button id="mic-button">🎤</button>
    <input id="chat-input" type="text" placeholder="메시지를 입력하세요..." autocomplete="off" />
    <button id="send-btn">➤</button>
  </div>

  <script type="module">
    import './js/firebase-config.js';
    import { getInitialGreeting, getGptResponse, getKoreanVocativeParticle } from './js/gpt-dialog.js';
    import { playTTSFromText, stopCurrentTTS } from './js/tts.js'; // `stopCurrentTTS`도 import
    import LOZEE_ANALYSIS from './js/lozee-analysis.js';
    import { saveSessionLog } from './js/firebase-utils.js';
    import { counselingTopicsByAge } from './js/counseling_topics.js';

    // 상태
    let skipTTS = false;
    let hasGreeted = false;
    let isProcessing = false;
    let chatHistory = [];
    let selectedMain = null;
    let meta = { lastInputTimestamp: Date.now(), fillerCount: 0, clickedOption: false, presentedIndices:[] };
    let isPlayingTTS = false; // TTS 재생 상태 추적

    // UI 요소
    const chatWindow = document.getElementById('chat-window');
    const topicArea = document.getElementById('topic-area'); // 이제 사용 안 할 수 있지만, 변수는 유지 (오류 방지)
    const inputArea = document.getElementById('input-area');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const micButton = document.getElementById('mic-button');
    const menuToggle = document.getElementById('menu-toggle');
    const dropdownMenu = document.getElementById('dropdown-menu');
    const meterLevel = document.getElementById('volume-level');

    // GNB 메뉴 토글
    menuToggle.addEventListener('click', () => dropdownMenu.classList.toggle('show'));
    document.addEventListener('click', e => {
      if (!document.getElementById('gnb').contains(e.target)) {
        dropdownMenu.classList.remove('show');
      }
    });

    // 사용자 정보 (localStorage에서 가져오기)
    const userName = localStorage.getItem('lozee_username') || '친구';
    const userAge = parseInt(localStorage.getItem('lozee_userage') || '0', 10);
    const voc = getKoreanVocativeParticle(userName); // gpt-dialog.js에서 export 필요

    // 초기화 로직 (단일 DOMContentLoaded 리스너)
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('✅ js/firebase-config.js 모듈 로드됨');
      console.log('DOMContentLoaded 이벤트 발생');

      const greeting = getInitialGreeting(userName + voc, hasGreeted); // gpt-dialog.js에서 export 필요
      appendMessage(greeting, 'ai');
      
      try {
        await playTTSWithControl(greeting);
      } catch (error) {
        console.warn("첫 TTS 자동 재생 실패 (사용자 상호작용 필요할 수 있음):", error);
        // TODO: 사용자에게 클릭 유도 메시지 표시 또는 다른 대안 고려
      }
      
      hasGreeted = true;
      showMainTopics();
    });

    // 메시지 관련 함수
    function appendMessage(text, role) {
      const bubble = document.createElement('div');
      bubble.className = 'bubble ' + role;
      bubble.textContent = text;
      chatWindow.appendChild(bubble);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function showAnalysis() {
      const notification = document.createElement('div');
      notification.className = 'analysis-notification';
      notification.textContent = '🟡분석 완료';
      notification.onclick = () => location.href = 'analysis.html'; // analysis.html이 실제로 존재하는지 확인 필요
      chatWindow.appendChild(notification);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    // TTS 제어 재생 함수
    async function playTTSWithControl(txt) {
      stopCurrentTTS(); // tts.js에서 export 필요
      if (skipTTS) {
        skipTTS = false;
        return Promise.resolve(); // TTS 건너뛸 때도 Promise 반환 일관성
      }
      isPlayingTTS = true;
      try {
        await playTTSFromText(txt, localStorage.getItem('lozee_voice')); // tts.js에서 export 필요
      } catch (error) {
        console.error("playTTSWithControl 내 TTS 재생 오류:", error);
        // 오류 발생 시에도 isPlayingTTS 상태 업데이트
      } finally {
        isPlayingTTS = false;
      }
    }

    // 오디오 분석 관련 (Web Audio API)
    let audioContext, analyser, source, dataArray, animId, streamRef;
    const LOW = { r:0, g:200, b:0 };
    const MID = { r:255, g:200, b:0 };
    const HIGH = { r:255, g:69, b:0 };

    function interp(c1, c2, f) {
      return `rgb(${Math.round(c1.r + f * (c2.r - c1.r))},${Math.round(c1.g + f * (c2.g - c1.g))},${Math.round(c1.b + f * (c2.b - c1.b))})`;
    }

    function setupAudioAnalysis(stream) {
      if (audioContext) audioContext.close();
      audioContext = new AudioContext();
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      source = audioContext.createMediaStreamSource(stream);
      source.connect(analyser);
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      streamRef = stream; // 나중에 트랙 중지를 위해 스트림 참조 저장
      draw();
    }

    function draw() {
      animId = requestAnimationFrame(draw);
      if (!analyser || !dataArray) return;
      analyser.getByteFrequencyData(dataArray);
      let sum = dataArray.reduce((a, v) => a + v, 0);
      let avg = sum / dataArray.length;
      let norm = Math.min(100, Math.max(0, (avg / 140) * 100));
      meterLevel.style.width = norm + '%';
      let col = norm <= 50 ? interp(LOW, MID, norm / 50) : interp(MID, HIGH, (norm - 50) / 50);
      meterLevel.style.background = `linear-gradient(to right, var(--background-color), ${col})`;

      // 사용자 음성 감지 시 TTS 중단 (STT 활성화 및 TTS 재생 중에만)
      if (norm > 10 && isRec && isPlayingTTS && !skipTTS) {
        console.log("사용자 음성 감지, TTS 중단 시도");
        stopCurrentTTS();
        skipTTS = true;
      }
    }

    function stopAudio() {
      if (animId) cancelAnimationFrame(animId);
      if (source) source.disconnect();
      if (streamRef) streamRef.getTracks().forEach(track => track.stop());
      if (audioContext) audioContext.close();
      meterLevel.style.width = '0%';
      // meterLevel 기본 배경색 설정 (CSS 변수 사용 권장)
      meterLevel.style.background = getComputedStyle(document.documentElement).getPropertyValue('--volume-meter-container-bg');
    }

    // STT (Web Speech API)
    const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recog, isRec = false;

    if (SpeechRecognitionAPI) {
      recog = new SpeechRecognitionAPI();
      recog.continuous = true; // 연속적인 결과 반환 안 함 (하나의 문장 완성 후 결과)
      recog.interimResults = false; // 중간 결과 반환 안 함
      recog.lang = 'ko-KR';

      recog.onstart = () => {
        isRec = true;
        micButton.classList.add('recording');
      };
      recog.onend = () => {
        isRec = false;
        micButton.classList.remove('recording');
        stopAudio(); // STT 종료 시 오디오 분석도 중지
      };
      recog.onresult = event => {
        let transcript = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            transcript += event.results[i][0].transcript;
          }
        }
        if (transcript) {
          console.log("STT 결과:", transcript);
          sendMessage(transcript);
        }
      };
      recog.onerror = event => {
        console.error('Speech recognition error:', event.error);
        appendMessage('음성 인식 오류: ' + event.error, 'ai_feedback');
        isRec = false;
        micButton.classList.remove('recording');
        stopAudio();
      };

      micButton.onclick = async () => {
        if (isRec) {
          recog.stop();
        } else {
          stopCurrentTTS(); // 현재 TTS 중지
          skipTTS = true;   // 다음 AI 응답 TTS 건너뛰기

          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            setupAudioAnalysis(stream); // 오디오 분석 시작
            recog.start();
          } catch (e) {
            console.error('마이크 접근 오류:', e);
            appendMessage('마이크 사용 권한이 필요합니다.', 'ai_feedback');
          }
        }
      };
    } else {
      micButton.disabled = true;
      appendMessage('이 브라우저에서는 음성 인식을 지원하지 않습니다.', 'ai_feedback');
    }

    // 토픽 플로우 - 선택창 (채팅창 내 버튼 표시)
    function displayOptionsInChat(optionsArray, onSelectCallback, context = null) {
      console.log("displayOptionsInChat 함수 시작됨, 옵션 배열:", optionsArray); // 옵션 배열의 실제 내용 확인
      const optionsContainer = document.createElement('div');
      optionsContainer.className = 'chat-options-container';

      const buttons = []; 

  // optionsArray가 { icon: "😊", displayText: "이야기" } 형태의 객체 배열이라고 가정
  optionsArray.forEach(optionObject => { // optionText 대신 optionObject로 변경
    // optionObject가 실제로 객체인지, 필요한 속성(icon, displayText)을 가지고 있는지 확인
    if (optionObject && typeof optionObject.displayText !== 'undefined') {
        console.log("옵션 버튼 생성 중:", optionObject.displayText);
        const button = document.createElement('button');
        button.className = 'chat-option-btn';
        
        // 이모지가 있다면 함께 표시, 없다면 displayText만 표시
        button.textContent = optionObject.icon ? `${optionObject.icon} ${optionObject.displayText}` : optionObject.displayText;

        button.onclick = () => {
          buttons.forEach(btn => {
            btn.disabled = true; 
            if (btn === button) {
              btn.classList.add('selected'); 
            }
          });
          onSelectCallback(optionObject.displayText, context); 
        };
        optionsContainer.appendChild(button);
        buttons.push(button);
    } else {
        // optionsArray의 요소가 예상한 객체 형태가 아닐 경우 로그를 남기거나 오류 처리
        console.warn("displayOptionsInChat: 잘못된 형식의 옵션 객체입니다.", optionObject);
    }
  });

  chatWindow.appendChild(optionsContainer);
  console.log("옵션 컨테이너가 chatWindow에 추가됨");
  chatWindow.scrollTop = chatWindow.scrollHeight;
}

    // 토픽 플로우 - 주제 (수정된 로직)
    function showMainTopics() {
      console.log("showMainTopics 함수 시작됨");
      appendMessage('어떤 이야기를 나눠볼까?', 'ai');
  
        const currentAgeGroup = getAgeGroup();
        const ageGroupData = counselingTopicsByAge[currentAgeGroup];
        let topicsWithOptions = []

        if (ageGroupData) {
        topicsWithOptions = Object.keys(ageGroupData).map(categoryName => {
           // 각 카테고리의 첫 번째 주제 항목에서 아이콘을 가져오거나,
           // 카테고리 자체에 대표 아이콘을 지정하는 방식이 필요합니다.
           // 여기서는 임시로 기본 아이콘을 사용하거나, 첫 번째 항목의 아이콘을 사용합니다.
           let icon = '💬'; // 기본 아이콘
           if (ageGroupData[categoryName] && ageGroupData[categoryName].length > 0 && ageGroupData[categoryName][0].icon) {
             icon = ageGroupData[categoryName][0].icon;
           }
           return { icon: icon, displayText: categoryName };
        });
     } else {
       console.warn(`counselingTopicsByAge에 '${currentAgeGroup}'에 대한 데이터가 없습니다.`);
     }

     topicsWithOptions.push({ icon: '🗣️', displayText: '자유주제' });
  
     console.log("displayOptionsInChat에 전달될 배열:", topicsWithOptions); // 수정된 배열 확인
     displayOptionsInChat(topicsWithOptions, (selectedTopicText) => {
     selectedMain = selectedTopicText;
     appendMessage(selectedMain + ' 이야기를 선택했구나!', 'ai'); 
     setTimeout(showSubTopics, 300);
    });
  if (topicArea) topicArea.style.display = 'none !important';
  }
   
    function showSubTopics() {
      // selectedMain이 null이거나 유효하지 않으면 실행되지 않도록 방어 코드 추가
     if (!selectedMain) {
    console.warn("showSubTopics 호출되었으나, selectedMain이 설정되지 않았습니다.");
    return; 
    }
    console.log("showSubTopics 함수 시작됨, 선택된 메인 주제:", selectedMain);
    appendMessage('조금 더 구체적으로 이야기해 줄래?', 'ai');
  
    let subtopics;
    if (selectedMain === '자유주제') {
    subtopics = ['응, 자유롭게 이야기 시작해줘!'];
    } else {
    const ageGroupTopics = counselingTopicsByAge[getAgeGroup()];
    const mainTopicDetails = ageGroupTopics && ageGroupTopics[selectedMain];
    subtopics = mainTopicDetails ? mainTopicDetails.map(item => item.displayText) : ['대화를 시작할 준비가 됐어.'];
    if (!subtopics.length) {
        subtopics = ['바로 대화 시작할까?'];
    }
  }

  // displayOptionsInChat의 콜백은 사용자가 버튼을 "클릭"했을 때만 실행되어야 합니다.
  displayOptionsInChat(subtopics, (selectedSubtopicByUser) => { // 콜백 파라미터명 변경
    console.log("하위 주제 선택됨:", selectedSubtopicByUser); // 디버깅 로그
    startChat(selectedSubtopicByUser); // 선택된 하위 주제로 대화 시작
  });
  if (topicArea) topicArea.style.display = 'none !important';
}

    function startChat(initText) {
      console.log("startChat 함수 시작됨, 초기 메시지:", initText);
      if (topicArea) topicArea.style.display = 'none !important';
      inputArea.style.display = 'flex'; // 입력창 표시
      sendMessage(initText);
    }   

    function getAgeGroup() {
      if (userAge <= 10) return '7-10';
      if (userAge <= 15) return '11-15';
      return '30+'; // 기본값 또는 성인
    }  

    // Stuck Detection (사용자 요청으로 showPreferenceOptions는 제거됨)
    function detectStuck(txt, his, meta) {
      const now = Date.now();
      if (meta.lastInputTimestamp && (now - meta.lastInputTimestamp) > 300000) return true; // 5분 이상 입력 없을 때
      if (meta.fillerCount >= 3) return true; // 필러 3회 이상
      const recentUserMessages = his.filter(m => m.role === 'user').slice(-5);
      if (recentUserMessages.length === 5 && recentUserMessages.every(m => m.content.trim().length < 5)) return true; // 최근 5회 사용자 발화 매우 짧음
      if (meta.clickedOption) return false; // 옵션 클릭 직후는 stuck 아님
      return false;
    }
    // showPreferenceOptions 함수는 제거됨

    // 메시지 전송 함수
    async function sendMessage(text) {
      if (!text || String(text).trim() === '' || isProcessing) return;
      isProcessing = true;
      sendBtn.classList.add('loading');

      appendMessage(text, 'user');
      chatHistory.push({ role: 'user', content: text });
      chatInput.value = '';

      try {
        const res = await getGptResponse(text, { chatHistory }); // gpt-dialog.js에서 export 필요
        if (!res.ok) {
            const errorData = await res.text();
            throw new Error(`GPT API 오류 ${res.status}: ${errorData}`);
        }
        const d = await res.json();
        const cut = d.text.indexOf('{'); // 분석 JSON이 함께 올 경우 잘라내기
        const clean = cut >= 0 ? d.text.slice(0, cut).trim() : d.text.trim();
        
        appendMessage(clean, 'ai');
        await playTTSWithControl(clean);
        
        chatHistory.push({ role: 'ai', content: clean });
        await saveSessionLog(text, clean, d.analysis || {}); // firebase-utils.js에서 export 필요

        if (d.analysis) {
          // LOZEE_ANALYSIS.trackEmotionTone(d.analysis); // 필요시 호출
          // LOZEE_ANALYSIS.trackSituation(d.analysis); // 필요시 호출
          if (LOZEE_ANALYSIS && LOZEE_ANALYSIS.inferAgeAndLanguage) { // lozee-analysis.js에서 export 필요
             await LOZEE_ANALYSIS.inferAgeAndLanguage(chatHistory.map(m=>m.role+':'+m.content).join('\n'));
          }
          showAnalysis(); // 분석 완료 알림 표시
        }
      } catch (error) {
        console.error("sendMessage 내 오류:", error);
        appendMessage("미안, 지금은 답변하기 조금 어려워. 잠시 후 다시 시도해 줄래?", "ai_feedback");
      } finally {
        isProcessing = false;
        sendBtn.classList.remove('loading');
      }
    }   

    // 이벤트 바인딩
    sendBtn.addEventListener('click', () => sendMessage(chatInput.value));
    chatInput.addEventListener('keydown', e => {
      meta.lastInputTimestamp = Date.now();
      const fillers = ['음','…','어','글쎄','모르겠어요','잘 모르겠어'];
      meta.fillerCount = fillers.some(f => chatInput.value.includes(f)) ? meta.fillerCount + 1 : 0;
      meta.clickedOption = false;
      
      stopCurrentTTS();
      skipTTS = true;
      
      if (e.key === 'Enter' && !e.isComposing) { // 한글 입력 완료 후 Enter 키 이벤트 처리
        e.preventDefault(); // Enter 키 기본 동작(줄바꿈 등) 방지
        sendMessage(chatInput.value);
      }
    });
  </script>
</body>
</html>