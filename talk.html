<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LOZEE와 대화하기</title>
  <link href="https://fonts.googleapis.com/css2?family=KoPub+World+Dotum:wght@400;700&display=swap" rel="stylesheet"/>
  <style>
    /* 기본 스타일 */
    :root {
  --primary-color: #6e8efb;
  --secondary-color: #354157;
  --background-color: #2a3340;
  --text-color: #fff;
  --input-background: #f0f0f0;
  --bot-bubble-bg: #f0f0f0;
  --bot-bubble-text: #333;
  --user-bubble-bg: #6e8efb; /* 사용자 말풍선은 원래 이 색이었습니다 */
  --user-bubble-text: #fff;   /* 사용자 말풍선 글씨도 흰색 */
  --gnb-height: 56px;
  --chat-input-height: 70px;
  --gemini-purple: #7B68EE; /* GNB 제목 및 메뉴 토글 원래 색상 */
  --volume-meter-default-bg: var(--primary-color);
  --meter-top-margin: 8px;
  --gnb-dropdown-border-color: #4a5568;
}

body {
  margin: 0;
  padding-top: var(--gnb-height);
  font-family: 'KoPub World Dotum', sans-serif;
  /* 그라데이션 배경 적용 */
  background: linear-gradient(135deg, var(--background-color-gradient-start), var(--background-color-gradient-end));
  color: var(--text-color); /* 주 텍스트 색상, 흰색 유지 또는 어두운색으로 변경 */
  display: flex;
  flex-direction: column;
  height: 100vh;
  box-sizing: border-box;
  overflow: hidden;
}

/* GNB 및 채팅 입력창 배경은 그라데이션과 어울리도록 반투명 흰색 또는 단색으로 조정 가능 */
#gnb {
  /* ... 기존 스타일 ... */
  background-color: rgba(255, 255, 255, 0.15); /* 예시: 약간 투명한 흰색 배경 */
  backdrop-filter: blur(10px); /* (선택사항) 블러 효과로 고급스러움 추가 */
  box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* 그림자 약간 연하게 */
}
#gnb-title {
  color: #ffffff; /* GNB 배경이 밝아지면 제목 색상 변경 가능 */
}
#menu-toggle {
    color: #ffffff; /* GNB 배경이 밝아지면 메뉴 토글 색상 변경 가능 */
}

#chat-input-container {
  /* ... 기존 스타일 ... */
  background-color: rgba(255, 255, 255, 0.2); /* 예시: 약간 투명한 흰색 배경 */
  backdrop-filter: blur(5px);
}

#chat-input {
  /* ... 기존 스타일 ... */
  background-color: var(--input-background); /* 이미 흰색 계열 */
  color: #333; /* 입력 글씨는 어둡게 */
  border: 1px solid #d0d0d0; /* 테두리 약간 연하게 */
}

/* 드롭다운 메뉴, 음량 바 등도 필요시 색상 조정 */
#dropdown-menu {
    background-color: rgba(40, 50, 65, 0.9); /* 약간 어두운 반투명 배경 유지 */
    backdrop-filter: blur(5px);
}
#dropdown-menu a {
    border-bottom: 1px solid var(--gnb-dropdown-border-color);
}
#dropdown-menu a:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

/* 시스템 오류 메시지 버블 배경색 변경 */
.bubble.system-error {
    background-color: #ffe0e0; /* 연한 핑크/빨강 */
    color: #c0392b; /* 어두운 빨강 글씨 */
    border: 1px solid #e74c3c;
}

    body {
      margin: 0;
      padding-top: var(--gnb-height);
      font-family: 'KoPub World Dotum', sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      height: 100vh;
      box-sizing: border-box;
      overflow: hidden;
    }

    /* GNB (햄버거 메뉴) */
    #gnb {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: var(--gnb-height);
      background-color: var(--background-color);
      padding: 0 16px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-sizing: border-box;
    }

    #gnb-title {
      font-size: 1.2em;
      font-weight: bold;
      color: var(--gemini-purple);
    }

    #menu-toggle {
      background: none;
      border: none;
      color: var(--gemini-purple);
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #dropdown-menu {
      position: fixed;
      top: var(--gnb-height);
      right: 0;
      background-color: var(--background-color);
      border-radius: 0 0 0 8px;
      box-shadow: -3px 3px 6px rgba(0,0,0,0.25);
      width: 200px;
      z-index: 999;
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.3s ease-out;
    }

    #dropdown-menu.show {
      max-height: 500px;
    }

    #dropdown-menu a {
      display: block;
      color: var(--text-color);
      text-decoration: none;
      padding: 12px 16px;
      font-size: 0.95em;
      border-bottom: 1px solid var(--gnb-dropdown-border-color);
    }
    #dropdown-menu a:last-child { border-bottom: none; }
    #dropdown-menu a:hover {
      background-color: var(--secondary-color);
    }

    /* 음량 바 */
    #meter-container {
      position: fixed;
      top: calc(var(--gnb-height) + var(--meter-top-margin));
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      max-width: 300px;
      height: 6px;
      background-color: var(--secondary-color);
      border-radius: 3px;
      overflow: hidden;
      z-index: 998;
    }
    #volume-meter { width:100%; height:100%; }
    #volume-level {
      width: 0%;
      height: 100%;
      background: var(--volume-meter-default-bg);
      border-radius: 3px;
      transition: width 0.05s linear;
    }

    /* 채팅 영역 */
    #chat-container {
      flex-grow: 1;
      padding: 16px;
      padding-top: calc(var(--meter-top-margin) + 6px + 16px);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: var(--chat-input-height);
    }

    .bubble {
      padding: 12px 16px;
      border-radius: 18px;
      max-width: 75%;
      line-height: 1.5;
      word-break: keep-all;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .bubble.user {
      background-color: var(--user-bubble-bg);
      color: var(--user-bubble-text);
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .bubble.bot {
      background-color: var(--bot-bubble-bg);
      color: var(--bot-bubble-text);
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .bubble.user.interim { opacity:.7; }
    .bubble.system-error { /* 오류 메시지 스타일 */
        background-color: #ffdddd;
        color: #d32f2f;
        align-self: center;
        max-width: 80%;
        text-align: center;
        font-size: 0.9em;
        border: 1px solid #d32f2f;
    }


    /* 입력 영역 */
    #chat-input-container {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: var(--chat-input-height);
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 12px;
      background-color: var(--secondary-color);
      box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
      box-sizing: border-box;
    }

    #chat-input {
      flex: 1;
      padding: 12px 16px;
      border-radius: 22px;
      border: 1px solid var(--gnb-dropdown-border-color);
      font-size: 1em;
      background-color: var(--input-background);
      color: #333;
      height: 44px;
      box-sizing: border-box;
    }
    #chat-input::placeholder { color: #777; }

    #mic-button,
    #send-button {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 50%;
      background-color: var(--primary-color);
      color: var(--text-color);
      font-size: 1.3em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s ease;
    }
    #mic-button:hover,
    #send-button:hover { background-color: #5a7edf; }
    #mic-button.disabled,
    #send-button.disabled {
      opacity:.5;
      cursor:default;
      background-color: #999;
    }
    #send-button.loading { background:#999; cursor:default; }

    /* 스크롤바 스타일 */
    #chat-container::-webkit-scrollbar { width: 8px; }
    #chat-container::-webkit-scrollbar-track { background: var(--background-color); }
    #chat-container::-webkit-scrollbar-thumb { background: var(--gnb-dropdown-border-color); border-radius: 4px; }
    #chat-container::-webkit-scrollbar-thumb:hover { background: #5a7edf; }
  </style>
</head>
<body>
  <nav id="gnb">
    <div id="gnb-title">LOZEE</div>
    <button id="menu-toggle" aria-label="메뉴 열기/닫기">&#9776;</button>
    <div id="dropdown-menu">
      <a href="#">MY PAGE (준비중)</a>
      <a href="index.html">주제 변경</a>
      <a href="analysis.html">최근 대화 분석</a>
      <a href="journal-list.html">주제별 대화 목록</a>
      <a href="https://www.notion.so/maenglionworld/lOZEE-1ebbcdc037cd80fa9c0ddef234121e84?pvs=4" target="_blank" rel="noopener noreferrer">LOZEE 소개</a>
    </div>
  </nav>

  <div id="meter-container">
    <div id="volume-meter">
      <div id="volume-level"></div>
    </div>
  </div>

  <div id="chat-container"></div>

  <div id="chat-input-container">
    <button id="mic-button" title="음성 인식 시작/중지">🎤</button>
    <input type="text" id="chat-input" placeholder="메시지를 입력하세요..." autocomplete="off"/>
    <button id="send-button" title="메시지 전송">⮞</button>
  </div>

  <script src="./js/gpt-dialog.js"></script>
  <script src="./js/tts.js"></script>

<script>
    // 전역 변수 선언 (랭킹 기능 및 기타 필요한 변수들)
    let isInRankingMode = false;
    let rankingType = null; // 'likes' 또는 'dislikes'
    let itemsToRank = [];
    let comparisonPairs = [];
    let currentPairIndex = 0;
    let comparisonScores = {}; // { "아이템명": 점수 }
    const MAX_ITEMS_TO_RANK = 5; // 순위 매길 최대 아이템 수

    let chatContainer; // 전역에서 접근 가능하도록 변경
    let chatInput;
    let sendButton;
    let micButton;
    let meterLevel;
    let menuToggle;
    let dropdownMenu;
    let gnb;

    let playTTSFunction;
    let currentDefaultVoice;
    let lsSelectedVoice; // lsSelectedVoice도 여기서 선언

    // 사용자 정보 (initializeApp에서 로드)
    let userAge;
    let userName;
    let userId;
    let userDisease; // JSON 파싱된 배열 형태로 저장 예정
    let selectedTopic;
    let chatHistory = [];


    // --- DOM 요소 가져오기 및 초기화 ---
    function initializeDOMElements() {
        chatContainer = document.getElementById('chat-container');
        chatInput     = document.getElementById('chat-input');
        sendButton    = document.getElementById('send-button');
        micButton     = document.getElementById('mic-button');
        meterLevel    = document.getElementById('volume-level');
        menuToggle    = document.getElementById('menu-toggle');
        dropdownMenu  = document.getElementById('dropdown-menu');
        gnb           = document.getElementById('gnb');
    }

    // --- 말풍선 및 UI 관련 함수 ---
    function appendBubble(textOrContent, role, choices = null) {
        if (!chatContainer) {
            console.error("CRITICAL: chatContainer element not found in the DOM. appendBubble cannot function.");
            return;
        }
        const bubbleEl = document.createElement('div');
        bubbleEl.className = `bubble ${role}`;

        if (typeof textOrContent === 'string') {
            const p = document.createElement('p');
            p.textContent = textOrContent;
            bubbleEl.appendChild(p);
        } else if (textOrContent instanceof HTMLElement) {
            bubbleEl.appendChild(textOrContent);
        }

        if (role === 'system-error') {
            bubbleEl.classList.add('system-error');
        }

        if (choices && Array.isArray(choices)) {
            const choicesContainer = document.createElement('div');
            choicesContainer.className = 'choices-container'; // CSS 스타일 필요 (아래 예시 CSS 참고)
            choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'choice-button'; // CSS 스타일 필요
                button.textContent = choice.text;
                button.onclick = () => {
                    choicesContainer.querySelectorAll('.choice-button').forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = "0.7"; // 시각적 피드백
                    });
                    choice.action(choice.value); // 콜백 함수 실행
                };
                choicesContainer.appendChild(button);
            });
            bubbleEl.appendChild(choicesContainer);
        }
        chatContainer.appendChild(bubbleEl);
        requestAnimationFrame(() => chatContainer.scrollTop = chatContainer.scrollHeight);
    }

    function showInterim(text) {
        if (!chatContainer) return;
        let el = document.querySelector('.bubble.user.interim');
        if (!el) { el = document.createElement('div'); el.className = 'bubble user interim'; chatContainer.appendChild(el); }
        el.textContent = text; requestAnimationFrame(() => chatContainer.scrollTop = chatContainer.scrollHeight);
    }

    function setLoading(flag) {
        if (sendButton) sendButton.disabled = flag;
        if (micButton) { // SpeechRecognition 지원 여부와 별개로 micButton 존재 여부 확인
             if (SpeechRecognition) micButton.disabled = flag && !isRecognizing;
             else micButton.disabled = true; // SpeechRecognition 미지원이면 항상 비활성화
        }
        if (sendButton) sendButton.classList.toggle('loading', flag);
    }

    // --- TTS 및 STT 관련 변수 및 함수 ---
    let audioContext;
    let analyser;
    let microphoneSource;
    let dataArray;
    let volumeMeterAnimationId;
    let analyserStream;
    let recognition;
    let isRecognizing = false;
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    // (setupAudioAnalysis, drawVolumeMeter, stopAudioAnalysis 함수는 기존 코드 유지 - 생략)
    // ... 기존 setupAudioAnalysis, drawVolumeMeter, stopAudioAnalysis 함수들을 여기에 붙여넣으세요 ...
    // (제공해주신 코드에는 이 함수들이 이미 잘 정의되어 있었습니다)
      function interpolateColor(color1, color2, factor) { /* ... 기존 코드 ... */ }
      function setupAudioAnalysis(stream) { /* ... 기존 코드 ... */ }
      function drawVolumeMeter() { /* ... 기존 코드 ... */ }
      function stopAudioAnalysis() { /* ... 기존 코드 ... */ }


    // --- 선호도 순위 매기기 관련 함수 ---
    function startRankingProcess(type) {
        isInRankingMode = true;
        rankingType = type;
        itemsToRank = [];
        comparisonPairs = [];
        currentPairIndex = 0;
        comparisonScores = {};

        const promptText = `네가 특별히 ${type === 'likes' ? '좋아하는' : '싫어하는(또는 화나는)'} 것들을 ${MAX_ITEMS_TO_RANK}개 이내로 알려줄래? 쉼표(,)로 구분해서 말해줘. (예: 게임, 강아지, 그림 그리기)`;
        appendBubble(promptText, 'bot');
        if (playTTSFunction) playTTSFunction(promptText, lsSelectedVoice);
    }

    function handleRankingItemInput(userInputText) {
        itemsToRank = userInputText.split(',')
            .map(item => item.trim())
            .filter(item => item)
            .slice(0, MAX_ITEMS_TO_RANK);

        if (itemsToRank.length < 2) {
            const errorText = `최소 두 개 이상은 말해줘야 순위를 정할 수 있어. 다시 한번 ${MAX_ITEMS_TO_RANK}개 이내로 알려줄래?`;
            appendBubble(errorText, 'bot');
            if (playTTSFunction) playTTSFunction(errorText, lsSelectedVoice);
            return;
        }

        itemsToRank.forEach(item => comparisonScores[item] = 0);
        for (let i = 0; i < itemsToRank.length; i++) {
            for (let j = i + 1; j < itemsToRank.length; j++) {
                comparisonPairs.push([itemsToRank[i], itemsToRank[j]]);
            }
        }

        if (comparisonPairs.length === 0 && itemsToRank.length > 0) { // 항목이 하나뿐일 경우
            const singleItemText = `${itemsToRank[0]}을(를) 가장 ${rankingType === 'likes' ? '좋아하는구나' : '싫어하는구나'}! 이 이야기에 대해 더 해볼까?`;
            appendBubble(singleItemText, 'bot', [
                { text: "응, 좋아!", value: itemsToRank[0], action: (chosenItem) => discussRankedItem(chosenItem, 1) },
                { text: "다른 이야기 할래", value: 'new_topic', action: () => {
                    isInRankingMode = false;
                    appendBubble("알겠어. 그럼 어떤 이야기를 하고 싶어?", "bot");
                    if(playTTSFunction) playTTSFunction("알겠어. 그럼 어떤 이야기를 하고 싶어?", lsSelectedVoice);
                }}
            ]);
            if(playTTSFunction) playTTSFunction(singleItemText, lsSelectedVoice);
            isInRankingMode = false;
            return;
        }
        currentPairIndex = 0;
        askNextComparison();
    }

    function askNextComparison() {
        if (currentPairIndex >= comparisonPairs.length) {
            finishRanking();
            return;
        }
        const pair = comparisonPairs[currentPairIndex];
        const questionText = `${pair[0]}(이)랑 ${pair[1]} 중에서는 어떤 게 더 ${rankingType === 'likes' ? '좋아' : '싫어(또는 화나)'}?`;
        
        appendBubble(questionText, 'bot', [
            { text: pair[0], value: pair[0], action: (chosenItem) => handleComparisonChoice(chosenItem, pair[1]) },
            { text: pair[1], value: pair[1], action: (chosenItem) => handleComparisonChoice(chosenItem, pair[0]) }
        ]);
        if (playTTSFunction) playTTSFunction(questionText, lsSelectedVoice);
    }

    function handleComparisonChoice(chosenItem, otherItemInPair) {
        appendBubble(`${chosenItem}! (선택)`, 'user'); // 사용자가 선택한 것처럼 표시
        comparisonScores[chosenItem]++;
        currentPairIndex++;
        askNextComparison();
    }

    function finishRanking() {
        const sortedItems = itemsToRank.sort((a, b) => comparisonScores[b] - comparisonScores[a]);
        let rankText = `알려줘서 고마워! 네가 ${rankingType === 'likes' ? '좋아하는' : '싫어하는(또는 화나는)'} 것들 순서는 이렇게 나왔어:\n`;
        const choicesForDiscussion = [];
        sortedItems.forEach((item, index) => {
            rankText += `${index + 1}. ${item} (점수: ${comparisonScores[item]})\n`;
            if (index < 3) {
                choicesForDiscussion.push({
                    text: `${item} 이야기하기`, value: item, 
                    action: (chosenItem) => discussRankedItem(chosenItem, index + 1)
                });
            }
        });
        choicesForDiscussion.push({ text: "다른 이야기 할래", value: 'new_topic', action: () => {
            isInRankingMode = false; 
            appendBubble("알겠어. 그럼 어떤 이야기를 하고 싶어?", "bot");
            if(playTTSFunction) playTTSFunction("알겠어. 그럼 어떤 이야기를 하고 싶어?", lsSelectedVoice);
        }});

        appendBubble(rankText.trim(), 'bot');
        if (playTTSFunction) playTTSFunction(rankText.trim(), lsSelectedVoice);
        
        setTimeout(() => {
            const discussPrompt = "이 중에서 오늘은 어떤 이야기에 대해 더 자세히 나눠볼까?";
            appendBubble(discussPrompt, 'bot', choicesForDiscussion);
            if(playTTSFunction) playTTSFunction(discussPrompt, lsSelectedVoice);
        }, 1000);

        isInRankingMode = false;
        localStorage.setItem('lozee_user_rankings', JSON.stringify({ type: rankingType, items: sortedItems.map(item => ({name: item, score: comparisonScores[item]})) }));
    }

    function discussRankedItem(item, rank) {
        appendBubble(`${item}에 대해 이야기하고 싶구나!`, 'user');
        const topicData = { type: 'ranked_preference', preference_type: rankingType, item: item, rank: rank };
        localStorage.setItem('lozee_last_active_topic', JSON.stringify(topicData));
        
        const getFirstQuestion = (window.LOZEE_DIALOG && window.LOZEE_DIALOG.getFirstQuestion) || ((age, topic) => "오류: 대화를 시작할 수 없습니다.");
        const firstQuestionForRankedItem = getFirstQuestion(userAge, topicData); 
        
        appendBubble(firstQuestionForRankedItem, 'bot');
        if (playTTSFunction) playTTSFunction(firstQuestionForRankedItem, lsSelectedVoice);
        chatHistory.push({ role: 'bot', content: firstQuestionForRankedItem, timestamp: new Date().toISOString() });
        localStorage.setItem('lozee_conversation_history', JSON.stringify(chatHistory)); // 첫 질문도 기록
    }

    // --- 대화 처리 로직 ---
    async function handleUserText(text) {
        const trimmedText = text.trim();
        if (!trimmedText) return;

        if (isInRankingMode && rankingType && itemsToRank.length === 0 && comparisonPairs.length === 0) {
            appendBubble(trimmedText, 'user'); // 사용자가 입력한 아이템 목록 표시
            handleRankingItemInput(trimmedText);
            chatInput.value = '';
            setLoading(false); 
            return;
        }
        // 랭킹 모드가 아니거나, 아이템 입력 단계가 지난 경우 일반 대화 처리
        document.querySelector('.bubble.user.interim')?.remove();
        appendBubble(trimmedText, 'user');
        chatHistory.push({ role: 'user', content: trimmedText, timestamp: new Date().toISOString() });
        setLoading(true);

        // "주제 없어" 등 특정 키워드로 랭킹 프로세스 시작 제안
        if (trimmedText.includes("주제 없어") || trimmedText.includes("뭐할지 모르겠어") || trimmedText.includes("이야기할 거 없어")) {
            const choices = [
                { text: "좋아하는 거 순위 매겨볼까?", value: 'likes', action: () => startRankingProcess('likes') },
                { text: "싫어하는 거 순위 매겨볼까?", value: 'dislikes', action: () => startRankingProcess('dislikes') },
                { text: "다른 이야기 할래", value: 'new_topic', action: () => {
                    appendBubble("알겠어. 그럼 어떤 이야기를 하고 싶니?", "bot");
                    if(playTTSFunction) playTTSFunction("알겠어. 그럼 어떤 이야기를 하고 싶니?", lsSelectedVoice);
                }}
            ];
            appendBubble("이야기할 주제를 정하기 어렵구나. 어떤 걸 해볼까?", 'bot', choices);
            if(playTTSFunction) playTTSFunction("이야기할 주제를 정하기 어렵구나. 어떤 걸 해볼까?", lsSelectedVoice);
            setLoading(false); chatInput.value = ''; chatInput.focus();
            return; 
        }

        try {
            const contextForGpt = { userId, userAge, userName, userDisease, chatHistory: chatHistory.slice(-10) };
            const getGptResponse = (window.LOZEE_DIALOG && window.LOZEE_DIALOG.getGptResponse) || (async () => ({ json: async () => ({ text: "오류: 응답을 받을 수 없습니다."}) }));
            
            const res = await getGptResponse(trimmedText, contextForGpt);
            console.log("GPT API 응답:", data);

            const botMessage = res?.content || "응답을 받지 못했어요.";

if (res.analysis) {
  // 분석 결과 처리
}
            const botResponseEntry = { role: 'bot', content: botMessage, timestamp: new Date().toISOString() };
            if (data.analysis) {
                console.log("💡 분석 데이터:", data.analysis);
                botResponseEntry.analysis = data.analysis;
                // 여기에 분석 결과(예: 감정 강도)에 따른 추가 로직이나 숫자 질문 로직 추가 가능
            }
            chatHistory.push(botResponseEntry);
            localStorage.setItem('lozee_conversation_history', JSON.stringify(chatHistory));
            if (playTTSFunction) await playTTSFunction(botMessage, lsSelectedVoice);

            // 숫자로 감정 강도 묻는 로직 (예시 조건)
            const userIntent = (window.LOZEE_DIALOG && window.LOZEE_DIALOG.detectIntent) ? window.LOZEE_DIALOG.detectIntent(trimmedText) : 'fact';
            if (userIntent === 'emotion' && botMessage.includes("어떤 기분인지 자세히 말해줄래")) { // 조건은 더 구체화 필요
                const numericScaleQuestion = `${userName}아/야, 지금 그 기분이 1부터 10까지 중에 몇 점 정도일까? 숫자가 클수록 더 강한 거야.`;
                appendBubble(numericScaleQuestion, 'bot');
                if (playTTSFunction) await playTTSFunction(numericScaleQuestion, lsSelectedVoice);
            }

        } catch (err) {
            console.error("❌ 처리 중 오류:", err);
            const errorMessage = "죄송해요, 내부 오류로 답변을 드릴 수 없어요.";
            appendBubble(errorMessage, 'system-error');
            chatHistory.push({ role: 'system', content: errorMessage, error: err.message, timestamp: new Date().toISOString() });
            localStorage.setItem('lozee_conversation_history', JSON.stringify(chatHistory));
            if (playTTSFunction) await playTTSFunction(errorMessage, lsSelectedVoice);
        }
        setLoading(false);
        chatInput.value = '';
        chatInput.focus();
    }

    // --- 초기화 및 이벤트 리스너 ---
    async function initConversation() {
        setLoading(true);
        const getFirstQuestion = (window.LOZEE_DIALOG && window.LOZEE_DIALOG.getFirstQuestion) || ((age, topic) => "오류: 대화를 시작할 수 없습니다.");
        const prompt = getFirstQuestion(userAge, selectedTopic);
        
        appendBubble(prompt, 'bot');
        chatHistory.push({ role: 'bot', content: prompt, timestamp: new Date().toISOString() });
        localStorage.setItem('lozee_conversation_history', JSON.stringify(chatHistory));
        if (playTTSFunction) {
            try { await playTTSFunction(prompt, lsSelectedVoice); }
            catch (ttsError) { console.error("TTS 오류 (초기 대화):", ttsError); }
        }
        setLoading(false);
    }

    async function initializeApp() {
        initializeDOMElements(); // DOM 요소 초기화

        if (!chatContainer) {
            console.error("CRITICAL: chatContainer element not found. Chat cannot function.");
            document.body.innerHTML = '<div style="color: red; font-size: 20px; text-align: center; padding: 50px; background-color: #fff; border: 2px solid red;">채팅 UI를 초기화할 수 없습니다. HTML 구조를 확인해주세요. (chat-container 누락)</div>';
            return;
        }

        // TTS 관련 초기화
        if (window.LOZEE_TTS && window.LOZEE_TTS.playTTSFromText && window.LOZEE_TTS.DEFAULT_VOICE) {
            playTTSFunction = window.LOZEE_TTS.playTTSFromText;
            currentDefaultVoice = window.LOZEE_TTS.DEFAULT_VOICE;
            console.log("tts.js (전역) 로드 성공. 기본 음성:", currentDefaultVoice);
        } else {
            console.error("tts.js가 올바르게 로드되지 않았거나, LOZEE_TTS 객체에 필요한 함수/변수가 정의되지 않았습니다.");
            playTTSFunction = async (text, voice) => { console.warn(`TTS Fallback (음성: ${voice}): ${text}. tts.js 로드 실패.`); };
            currentDefaultVoice = 'default-fallback-voice'; // 실제 음성 ID가 아님
            appendBubble("알림: 음성 출력(TTS) 기능을 불러오는 데 문제가 발생했습니다. 텍스트로만 대화가 진행됩니다.", "system-error");
        }
        lsSelectedVoice = localStorage.getItem('lozee_selectedVoice') || currentDefaultVoice;


        // GPT Dialog 관련 초기화
        if (!window.LOZEE_DIALOG || !window.LOZEE_DIALOG.getGptResponse || !window.LOZEE_DIALOG.getFirstQuestion) {
            console.error("gpt-dialog.js가 올바르게 로드되지 않았거나, LOZEE_DIALOG 객체에 함수들이 정의되지 않았습니다.");
            appendBubble("오류: 대화 기능을 초기화할 수 없습니다. 페이지를 새로고침하거나 관리자에게 문의하세요.", "system-error");
            // return; // 여기서 중단하면 다른 기능도 초기화 안 될 수 있으므로 일단 진행
        }

        // 사용자 정보 로드
        userAge = localStorage.getItem('lozee_userage');
        userName = localStorage.getItem('lozee_username') || '친구';
        userId = localStorage.getItem('lozee_userid') || `user_${Date.now()}`; // 간단한 고유 ID 생성
        try {
            userDisease = JSON.parse(localStorage.getItem('lozee_userdisease') || '[]');
            if (!Array.isArray(userDisease)) userDisease = [userDisease];
        } catch (e) { userDisease = []; }
        
        selectedTopic = JSON.parse(localStorage.getItem('selectedTopic') || '{}');
        chatHistory = JSON.parse(localStorage.getItem('lozee_conversation_history') || '[]');
        
        chatHistory.forEach(msg => { // 기존 대화 로드 시 선택지 버튼은 다시 만들지 않음
            if (typeof msg.content === 'string') { // 단순 텍스트만 다시 로드
                 appendBubble(msg.content, msg.role);
            } else if (msg.content && msg.content.text) { // 혹시 객체 형태로 저장되었다면
                 appendBubble(msg.content.text, msg.role);
            }
        });


        // 메뉴 토글
        if (menuToggle && dropdownMenu && gnb) {
            menuToggle.addEventListener('click', () => dropdownMenu.classList.toggle('show'));
            document.addEventListener('click', (event) => {
                if (!gnb.contains(event.target) && dropdownMenu.classList.contains('show')) {
                dropdownMenu.classList.remove('show');
                }
            });
        } else {
            console.warn("메뉴 관련 DOM 요소 중 일부가 없습니다.");
        }


        // 음성 인식 설정 (SpeechRecognition API)
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true; // STT가 자동으로 멈추지 않도록 (필요에 따라 false로 하고 onend에서 재시작)
            recognition.interimResults = true;
            recognition.lang = 'ko-KR';
            if(micButton) micButton.classList.remove('disabled');

            recognition.onstart = () => {
                isRecognizing = true; if(micButton) { micButton.textContent = '💬'; micButton.style.backgroundColor = '#e74c3c';} console.log("🎤 음성 인식 시작");
                 // 사용자가 말 시작 시 TTS 중단 (만약 LOZEE_TTS에 stop 함수가 있다면)
                if (window.LOZEE_TTS && typeof window.LOZEE_TTS.stopPlayback === 'function') {
                    window.LOZEE_TTS.stopPlayback();
                }
            };
            recognition.onend = () => {
                isRecognizing = false; if(micButton) { micButton.textContent = '🎤'; micButton.style.backgroundColor = 'var(--primary-color)';} console.log("🎤 음성 인식 종료"); 
                setLoading(false); 
                stopAudioAnalysis();
                // 필요시 여기서 자동으로 다시 recognition.start()를 호출하여 계속 듣도록 할 수 있으나, 사용자가 원할때만 하도록 현재는 유지
            };
            recognition.onresult = (event) => {
                let interimTranscript = '', finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    event.results[i].isFinal ? finalTranscript += event.results[i][0].transcript : interimTranscript += event.results[i][0].transcript;
                }
                if (interimTranscript && isRecognizing) showInterim(interimTranscript); // 인식 중에만 중간 결과 표시
                if (finalTranscript) { 
                    document.querySelector('.bubble.user.interim')?.remove(); 
                    if(chatInput) chatInput.value = finalTranscript; // 인식된 텍스트를 입력창에도 표시
                    handleUserText(finalTranscript); // 최종 결과로 대화 처리
                }
            };
            recognition.onerror = (event) => {
                console.error("❌ 음성 인식 오류:", event.error);
                appendBubble(event.error === 'not-allowed' || event.error === 'service-not-allowed' ? "마이크 사용 권한이 필요해요." : "음성 인식 중 오류가 발생했어요.", "system-error");
                isRecognizing = false; if(micButton) { micButton.textContent = '🎤'; micButton.style.backgroundColor = 'var(--primary-color)';}
                setLoading(false); stopAudioAnalysis();
            };
        } else {
            console.warn("⚠️ 음성 인식 미지원 브라우저");
            if(micButton) { micButton.title = "음성 인식 미지원"; micButton.disabled = true; }
            appendBubble("알림: 사용 중인 브라우저에서는 음성 인식을 지원하지 않습니다.", "system-error");
        }

        if(micButton) {
            micButton.addEventListener('click', async () => {
                if (!SpeechRecognition) return;
                if (isRecognizing) {
                    recognition.stop();
                } else {
                    try {
                        // TTS가 재생 중이라면 먼저 중지 (사용자 경험 개선)
                        if (window.LOZEE_TTS && typeof window.LOZEE_TTS.stopPlayback === 'function') {
                           await window.LOZEE_TTS.stopPlayback(); // 비동기일 수 있으므로 await
                        }
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        setupAudioAnalysis(stream); recognition.start(); setLoading(true); // STT 시작 시 로딩은 선택적
                    } catch (err) {
                        console.error("❌ 마이크 권한/시작 오류:", err); appendBubble("마이크를 사용할 수 없어요. 권한을 확인해주세요.", "system-error"); stopAudioAnalysis();
                    }
                }
            });
        }

        // 대화 시작 로직 (localStorage에 저장된 상태에 따라 분기)
        const savedRankingState = JSON.parse(localStorage.getItem('lozee_ranking_progress')); // 이 부분은 아직 미구현
        const savedLastTopic = JSON.parse(localStorage.getItem('lozee_last_active_topic'));

        if (savedRankingState /* && savedRankingState.isInRankingMode */) { // 랭킹 이어하기 로직 (미구현 상태)
            // TODO: 랭킹 이어하기 UI 및 로직 호출
            appendBubble("지난번에 하던 선호도 순위 매기기를 이어서 할까?", "bot", [
                { text: "응, 이어서 할래", value: "resume_ranking", action: () => { /* TODO: 랭킹 상태 복원 및 askNextComparison 호출 */ } },
                { text: "아니, 새로 시작할래", value: "new_topic_instead", action: () => {
                    localStorage.removeItem('lozee_ranking_progress');
                    localStorage.removeItem('lozee_last_active_topic');
                    initConversationWithOptionalTopicPrompt(); // 새로운 주제 선택 또는 첫 인사
                }}
            ]);
        } else if (savedLastTopic && savedLastTopic.item) {
             appendBubble(`지난번에 '${savedLastTopic.item}'에 대해 이야기했었는데, 계속 이야기해 볼까? 아니면 새로운 이야기를 하고 싶니?`, "bot", [
                { text: "응, 이어서 할래", value: "resume_topic", action: () => {
                    selectedTopic = savedLastTopic; // 선택된 주제로 설정
                    // GPT에게 이어서 대화하도록 유도 (chatHistory는 이미 로드됨)
                    const resumeMessage = `'${selectedTopic.item}' 이야기 계속하자!`;
                    appendBubble(resumeMessage, 'bot');
                    if(playTTSFunction) playTTSFunction(resumeMessage, lsSelectedVoice);
                    // chatHistory.push({role:'system', content: '사용자가 이전 대화 이어하기를 선택했습니다.'});
                    // 사용자가 뭔가 입력해야 다음 GPT 호출이 일어나므로, 로지가 먼저 말을 걸도록 유도하거나
                    // 혹은 사용자가 바로 다음 말을 할 수 있도록 안내
                }},
                { text: "새로운 이야기 할래", value: "new_topic_instead", action: () => {
                    localStorage.removeItem('lozee_last_active_topic');
                    chatHistory = []; // 새 이야기이므로 이전 대화 기록 초기화 (선택 사항)
                    localStorage.setItem('lozee_conversation_history', JSON.stringify(chatHistory));
                    document.querySelectorAll('.bubble').forEach(b => b.remove()); // 화면의 버블도 제거
                    initConversationWithOptionalTopicPrompt();
                }}
             ]);
        } else if (Object.keys(selectedTopic).length > 0 && chatHistory.length === 0) {
            await initConversation(); // 선택된 주제로 첫 대화 시작
        } else if (chatHistory.length === 0) { // 저장된 주제도 없고, 대화 기록도 없을 때
            initConversationWithOptionalTopicPrompt();
        }
        // 이미 대화 기록이 있다면(새로고침 등), 별도의 초기 메시지 없이 사용자 입력을 기다림

        function initConversationWithOptionalTopicPrompt() {
            if (Object.keys(selectedTopic).length > 0) {
                 initConversation();
            } else {
                 appendBubble("안녕! 오늘은 어떤 이야기를 해볼까? 아니면 내가 먼저 주제를 제안해 줄까?", "bot", [
                    {text: "내가 말할게", value: "user_defines", action: () => {
                        appendBubble("좋아! 어떤 이야기를 하고 싶은지 입력해줘.", "bot");
                        if(playTTSFunction) playTTSFunction("좋아! 어떤 이야기를 하고 싶은지 입력해줘.", lsSelectedVoice);
                    }},
                    {text: "로지가 골라줘", value: "lozee_picks", action: () => {
                        // 로지가 주제를 골라주는 로직 (gpt-dialog.js의 getFirstQuestion과 유사하게)
                        const randomTopicPrompt = (window.LOZEE_DIALOG && window.LOZEE_DIALOG.getFirstQuestion) ? window.LOZEE_DIALOG.getFirstQuestion(userAge, {displayText: "RANDOM_TOPIC_PLEASE"}) : "오늘은 날씨 이야기 어때?";
                        selectedTopic = {displayText: randomTopicPrompt}; // 임시로 설정
                        initConversation();
                    }}
                 ]);
                if(playTTSFunction) playTTSFunction("안녕! 오늘은 어떤 이야기를 해볼까? 아니면 내가 먼저 주제를 제안해 줄까?", lsSelectedVoice);
            }
        }


        // 전송 버튼 및 Enter 키 이벤트
        if (sendButton && chatInput) {
            sendButton.addEventListener('click', () => { const text = chatInput.value; handleUserText(text); });
            chatInput.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); const text = chatInput.value; handleUserText(text); 
                } 
            });
        } else {
            console.error("Send button 또는 Chat input DOM 요소를 찾을 수 없습니다.");
        }

        // 초기 로딩 시 약간의 지연을 두어 TTS.js 등이 로드될 시간을 확보 (선택적)
        // setTimeout(initializeApp, 50); // DOMContentLoaded 내부로 옮김
    } // initializeApp 끝

    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initializeApp, 100); // 약간의 지연을 늘려서 외부 스크립트 로드 보장 시도
    });

  </script>
</body>
</html>

