<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LOZEE 대화 (자동 STT)</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body { display:flex; flex-direction:column; min-height:100vh; margin:0; background:#fff; color:#333; font-family:'KoPubWorld Dotum',sans-serif; }
    #main-header { background:#0095FF; color:#fff; padding:1rem; text-align:center; font-size:20px; }
    #chat-window { flex:1; overflow-y:auto; padding:20px; display:flex; flex-direction:column; gap:12px; }
    .bubble { max-width:80%; padding:12px 18px; border-radius:20px; line-height:1.6; font-size:16px; white-space:pre-wrap; box-shadow:0 1px 3px rgba(0,0,0,0.1); }
    .user { background:#fff9c4; color:#333; align-self:flex-end; margin-left:auto; border-bottom-right-radius:5px; }
    .ai { background:#0095FF; color:#fff; align-self:flex-start; margin-right:auto; border-bottom-left-radius:5px; }
    #loading-indicator { text-align:center; padding:10px; display:none; color:#555; font-style:italic; }
  </style>
</head>
<body>
  <header id="main-header">LOZEE 대화</header>
  <div id="chat-window"></div>
  <div id="loading-indicator">음성 인식 중...</div>

  <script type="module">
    import { playTTSFromText } from './js/tts.js';
    import { getSTTFromAudio } from './js/stt.js';
    import { getGptResponse, getInitialGreeting } from './js/gpt-dialog.js';

    const STT_WS_URL = 'wss://ggg-production.up.railway.app/api/sttStream';
    const chatWindow  = document.getElementById('chat-window');
    const loading     = document.getElementById('loading-indicator');

    // 선택된 TTS 음성
    const ttsVoiceId = localStorage.getItem('lozee_tts_voice') || 'ko-KR-Chirp3-HD-Vindemiatrix';
    function currentVoice() { return localStorage.getItem('lozee_tts_voice') || ttsVoiceId; }

    // 메시지 추가
    function appendMessage(text, role) {
      const div = document.createElement('div');
      div.className = `bubble ${role}`;
      div.textContent = text;
      chatWindow.appendChild(div);
      chatWindow.scrollTop = chatWindow.scrollHeight;
      return div;
    }

    // 로딩 토글
    function toggleLoading(state) {
      loading.style.display = state ? 'block' : 'none';
    }

    let audioContext, micStream, processor, ws;

    window.addEventListener('DOMContentLoaded', async () => {
      // 초기 인사
      const userName = localStorage.getItem('lozee_username') || '친구';
      const greeting = await getInitialGreeting(userName);
      appendMessage(greeting, 'ai');
      await playTTSFromText(greeting, currentVoice());

      // 사용자가 선택한 감정 태그와 인트로 메시지 가져오기
      const emotionTag = localStorage.getItem('lozee_emotion_tag');
      const introText = localStorage.getItem('lozee_user_intro');
      if (introText) {
        // 첫 마디: 감정 태그와 인트로 전달
        const systemPrompt = emotionTag ? `유저 감정: ${emotionTag}.` : '';
        await handleUserTurn(introText, systemPrompt);
        localStorage.removeItem('lozee_user_intro');
      }

      // 실시간 스트리밍 STT 시작
      startStreamingSTT();
    });
    });

    // 스트리밍 STT 시작
    async function startStreamingSTT() {
      toggleLoading(true);
      appendMessage('...', 'user');
      const userBubble = chatWindow.lastChild;

      // WebSocket 연결
      ws = new WebSocket(STT_WS_URL);
      ws.binaryType = 'arraybuffer';
      ws.onopen = () => toggleLoading(true);
      ws.onmessage = async ({ data }) => {
        const msg = JSON.parse(data);
        if (msg.transcript) userBubble.textContent = msg.transcript;
        if (msg.isFinal) {
          ws.close(); toggleLoading(false);
          await handleUserTurn(userBubble.textContent);
          // 다시 자동 대기→인식
          startStreamingSTT();
        }
      };
      ws.onerror = () => {
        toggleLoading(false);
        appendMessage('스트리밍 오류, 폴백 모드', 'ai');
        stopStreamingSTT();
        startChunkedSTT();
      };

      // 오디오 캡처 및 전송
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const source = audioContext.createMediaStreamSource(micStream);
      processor = audioContext.createScriptProcessor(4096, 1, 1);
      source.connect(processor);
      processor.connect(audioContext.destination);
      processor.onaudioprocess = e => {
        const input = e.inputBuffer.getChannelData(0);
        const int16 = float32ToInt16(input);
        if (ws.readyState === WebSocket.OPEN) ws.send(int16);
      };
    }

    // 스트리밍 STT 중지
    function stopStreamingSTT() {
      if (processor) processor.disconnect();
      if (micStream) micStream.getTracks().forEach(t => t.stop());
      if (audioContext && audioContext.state !== 'closed') audioContext.close();
    }

    function float32ToInt16(buffer) {
      const l = buffer.length;
      const buf = new Int16Array(l);
      for (let i = 0; i < l; i++) buf[i] = Math.min(1, buffer[i]) * 0x7FFF;
      return buf.buffer;
    }

    // GPT 응답 처리
    async function handleUserTurn(text) {
      appendMessage(text, 'user');
      const res = await getGptResponse(text);
      const aiText = typeof res === 'string' ? res : (res.error || res.rephrasing || '응답이 없습니다.');
      appendMessage(aiText, 'ai');
      await playTTSFromText(aiText, currentVoice());
    }

    // 폴백: 청크 STT
    async function startChunkedSTT() {
      appendMessage('폴백 STT 모드로 인식합니다.', 'ai');
      try { stopStreamingSTT(); } catch {}
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const rec = new MediaRecorder(stream);
      let chunks = [];
      rec.ondataavailable = e => chunks.push(e.data);
      rec.onstop = async () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        chunks = [];
        try {
          const text = await getSTTFromAudio(blob);
          await handleUserTurn(text);
        } catch {
          appendMessage('청크 STT 오류', 'ai');
        }
        // 다시 자동 시작
        startStreamingSTT();
      };
      rec.start();
      setTimeout(() => rec.stop(), 5000);
    }
  </script>
</body>
</html>
