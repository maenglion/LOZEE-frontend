<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LOZEE와 대화</title>
  <link rel="stylesheet" href="style.css"> <link href="https://fonts.googleapis.com/css2?family=KoPub+World+Dotum:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* 기본 페이지 및 폰트 스타일 */
    body { 
      display: flex; 
      flex-direction: column; 
      min-height: 100vh; 
      background-color: #ffffff; 
      color: #333; 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      margin: 0;
    }

    /* 헤더 스타일 */
    #main-header {
      background-color: #0095FF; /* 로지 메인 컬러 */
      color: white;
      padding: 1rem;
      text-align: center;
      font-size: 20px;
      font-weight: bold;
      flex-shrink: 0; 
    }

    /* 채팅 컨테이너 및 창 스타일 */
    #chat-container { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
      overflow-y: hidden; 
      width: 100%; 
      max-width: 700px; 
      margin: 0 auto; 
      box-sizing: border-box; 
    }
    #chat-window { 
      flex: 1; 
      overflow-y: auto; 
      padding: 20px; 
      display: flex; 
      flex-direction: column; 
      gap: 12px; 
    }

    /* 말풍선 공통 스타일 */
    .bubble { 
      max-width: 80%; 
      padding: 12px 18px; 
      border-radius: 20px; 
      line-height: 1.6; 
      font-size: 16px; 
      white-space: pre-wrap; 
      box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
    }
    .user { 
      background-color: #fff9c4; 
      color: #333; 
      align-self: flex-end; 
      margin-left: auto; 
      border-bottom-right-radius: 5px; 
    }
    .ai { 
      background-color: #0095FF; 
      color: white; 
      align-self: flex-start; 
      margin-right: auto; 
      border-bottom-left-radius: 5px; 
    }
    .bubble.ai.error { 
      background-color: #ff7373; 
      color: white; 
    }

    /* 로딩 인디케이터 스타일 */
    #loading-indicator-talk { 
      text-align: center; 
      padding: 10px; 
      display: none; 
      color: #555; 
      font-style: italic; 
    }

    /* 하단 마이크 버튼 컨테이너 스타일 */
    #talk-btn-container { 
      padding: 15px 0; 
      background-color: #ffffff; 
      flex-shrink: 0; 
      text-align: center; 
      border-top: 1px solid #eee; 
    }
    #talk-btn { 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      width: 80px; 
      height: 80px; 
      border-radius: 50%; 
      background-color: #b6b6b6; 
      border: none; 
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); 
      color: white; 
      font-size: 36px; 
      cursor: pointer; 
      display: inline-flex; 
      justify-content: center; 
      align-items: center; 
      transition: transform 0.2s ease, background-color 0.3s; 
    }
    #talk-btn.active { 
      background-color: #0095FF; 
      transform: scale(1.1); 
    }
    #talk-btn:disabled { 
      background-color: #ccc; 
      cursor: not-allowed; 
      transform: scale(1.0); 
    }

    /* 주제 선택 박스 관련 스타일 */
    #topic-selection { 
      display: none; 
      background: #f0f0f0; 
      padding: 20px; 
      border-top: 1px solid #ddd; 
      text-align: center; 
      flex-shrink: 0; 
    }
    #topic-selection h3 { 
      font-size: 18px; 
      color: #333; 
      margin-top: 0; 
      margin-bottom: 15px; 
      font-weight: bold; 
    }
    .topic-option { 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      padding: 10px 15px; 
      margin: 8px auto; 
      background: white; 
      border: 1px solid #0095FF; 
      color: #0095FF; 
      border-radius: 10px; 
      cursor: pointer; 
      max-width: 320px; 
      font-size: 15px; 
      font-weight: bold; 
      transition: background-color 0.2s, color 0.2s; 
    }
    .topic-option:hover { 
      background-color: #0095FF; 
      color: white; 
    }

    /* 기다리는 중 오버레이 스타일 */
    #waiting-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8); 
        display: none; 
        justify-content: center;
        align-items: center;
        z-index: 1000; 
        color: white;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        cursor: pointer; 
    }
  </style>
</head>
<body>
  <header id="main-header">LOZEE와 대화하기</header>

  <div id="chat-container">
    <div id="chat-window">
    </div>
    <div id="topic-selection">
      <h3>이야기를 이어가고 싶은 주제를 골라볼래?</h3>
      <div id="topic-options">
      </div>
    </div>
  </div>

  <div id="loading-indicator-talk">AI 응답 준비 중...</div>
  
  <div id="talk-btn-container">
    <button id="talk-btn" aria-label="말하기">🎤</button>
  </div>

  <div id="waiting-overlay">
    <p><span id="waitingUserName"></span>님, 잠시 기다리는 중...<br><small>(화면을 클릭하면 다시 시작할 수 있어요)</small></p>
  </div>

  <script type="module">
    import { playTTSFromText } from './js/tts.js';
    import { getSTTFromAudio } from './js/stt.js';
    import { getGptResponse, getInitialGreeting } from './js/gpt-dialog.js';

    console.log("talk.html 스크립트 시작 (v3.4 - 온보딩 연동 강화)");

    const talkBtn = document.getElementById('talk-btn');
    const chatWindow = document.getElementById('chat-window');
    const topicBox = document.getElementById('topic-selection');
    const topicOptionsContainer = document.getElementById('topic-options');
    const loadingIndicatorTalk = document.getElementById('loading-indicator-talk');
    const waitingOverlay = document.getElementById('waiting-overlay');
    const waitingUserName = document.getElementById('waitingUserName');

    const currentUserName = localStorage.getItem('lozee_username') || "친구";
    const currentUserId = localStorage.getItem('lozee_username'); 
    const currentVoiceId = localStorage.getItem('lozee_voice');
    const currentUserAge = localStorage.getItem('lozee_userage');
    const currentUserDisease = localStorage.getItem('lozee_userdiagnosis');
    let hasVisited = localStorage.getItem('lozee_hasVisited') === 'true';
    let lastSummary = localStorage.getItem('lozee_lastSummary') || '';

    const onboardingComplete = localStorage.getItem('lozee_onboarding_complete') === 'true';
    const userTypedIntro = localStorage.getItem('lozee_user_typed_intro'); // intro.html에서 저장한 첫마디
    const selectedEmotionsString = localStorage.getItem('lozee_selected_emotions');
    let selectedEmotions = [];
    if (selectedEmotionsString) {
        try {
            selectedEmotions = JSON.parse(selectedEmotionsString);
        } catch (e) {
            console.error("선택된 감정 localStorage 파싱 오류:", e);
            selectedEmotions = [];
        }
    }


    console.log("사용자 정보:", { currentUserName, currentVoiceId, currentUserAge, currentUserDisease, hasVisited });
    console.log("온보딩 완료 여부:", onboardingComplete);
    if(onboardingComplete) {
        console.log("온보딩 데이터 -> 사용자 첫마디:", userTypedIntro, "선택된 감정:", selectedEmotions);
    }

    let isRecording = false;
    let mediaRecorder;
    let audioChunks = [];
    let mediaStream = null;
    let silenceTimer;
    const SILENCE_TIMEOUT = 20000; 
    let firstInteractionDone = false; 
    let initialGreetingText = "";    
    let recordingStartTime; 

    function appendMessage(text, role = 'ai', isError = false) {
      if (!text || String(text).trim() === "") { 
        console.log(`[appendMessage] 빈 메시지 (${role}), 추가 안함.`); 
        return null; 
      }
      console.log(`[appendMessage] (${role}): ${String(text).substring(0,50)}...`);
      const msgDiv = document.createElement('div'); 
      msgDiv.className = `bubble ${role}`;
      if (isError && role === 'ai') msgDiv.classList.add('error');
      const processedText = String(text).replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank">$1</a>');
      msgDiv.innerHTML = processedText; 
      
      if (role === 'user') { 
          chatWindow.appendChild(msgDiv);
          chatWindow.scrollTop = chatWindow.scrollHeight;
          resetSilenceTimer();
          return msgDiv; 
      } else { 
          return msgDiv; 
      }
    }

    function disableTalkButton(disable = true, reason = "") {
      talkBtn.disabled = disable;
      console.log(`[disableTalkButton] ${disable ? '비활성화' : '활성화'}${reason ? ` (${reason})` : ''}`);
    }

    async function loadRecentTopics() { /* ... (이전과 동일) ... */ }
    function showTopicBox(topics) { /* ... (이전과 동일, 침묵 처리 로직 반영) ... */ }
    function startSilenceTimer() { /* ... (이전과 동일) ... */ }
    function resetSilenceTimer() { /* ... (이전과 동일) ... */ }
    
    async function handleUserInteraction(userText, context = {}) {
      if (!userText || userText.trim() === "") { return; }
      console.log("[handleUserInteraction] AI 응답 처리 시작. 입력:", userText, "Context:", context);
      disableTalkButton(true, "AI 응답 대기 중"); 
      topicBox.style.display = 'none';
      loadingIndicatorTalk.style.display = 'block';

      try {
        const gptContext = { 
            userAge: currentUserAge, 
            userDisease: currentUserDisease,
            ...context 
        };
        const gptResponse = await getGptResponse(userText, currentUserId, gptContext); 
        
        let aiReply = "죄송해요, 답변을 이해하는 데 어려움이 있었어요.";
        let isError = true;

        if (gptResponse) {
            if (gptResponse.rephrasing) {
                aiReply = gptResponse.rephrasing; 
                isError = false;
                if (gptResponse.summary) { 
                    localStorage.setItem('lozee_lastSummary', gptResponse.summary); 
                    lastSummary = gptResponse.summary; 
                }
            } else if (gptResponse.error) { 
                aiReply = gptResponse.error; 
            }
        }
        
        setTimeout(async () => {
            loadingIndicatorTalk.style.display = 'none'; 
            const aiBubbleDiv = appendMessage(aiReply, 'ai', isError);
            if (aiBubbleDiv) { 
                chatWindow.appendChild(aiBubbleDiv); 
                chatWindow.scrollTop = chatWindow.scrollHeight;
                 try {
                    await playTTSFromText(aiReply, currentVoiceId); 
                 } catch (ttsError) {
                    console.error("TTS 재생 중 오류 발생 (handleUserInteraction):", ttsError);
                 }
            }
            disableTalkButton(false, "AI 응답 완료");
            resetSilenceTimer(); 
        }, 2000);

      } catch (error) { 
        console.error("[handleUserInteraction] AI 응답 처리 중 예외:", error);
        loadingIndicatorTalk.style.display = 'none';
        const fallbackMsg = "죄송합니다, 응답 처리 중 예상치 못한 문제가 발생했어요.";
        const errorBubble = appendMessage(fallbackMsg, 'ai', true);
        if(errorBubble) chatWindow.appendChild(errorBubble);
        try { await playTTSFromText(fallbackMsg, currentVoiceId); } catch (e) {}
        disableTalkButton(false, "AI 응답 오류");
        resetSilenceTimer(); 
      } 
    }

    async function startRecording() {
      if (isRecording) { return; }
      console.log("[startRecording] 녹음 시작 시도..."); 
      topicBox.style.display = 'none';
      waitingOverlay.style.display = 'none'; 
      try {
        if (mediaStream) { mediaStream.getTracks().forEach(track => track.stop()); }
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        isRecording = true; 
        talkBtn.classList.add('active'); 
        talkBtn.innerHTML = '⏹️'; 
        disableTalkButton(false, "녹음 중"); 
        audioChunks = []; 
        const options = { mimeType: 'audio/webm;codecs=opus' };
        mediaRecorder = new MediaRecorder(mediaStream, options); 
        recordingStartTime = performance.now(); 
        
        mediaRecorder.ondataavailable = event => { 
            if (event.data.size > 0) { audioChunks.push(event.data); }
        };
        mediaRecorder.onstop = async () => {
            console.log("[onstop] 녹음 중지됨, 처리 시작...");
            talkBtn.innerHTML = '🎤'; 
            talkBtn.classList.remove('active');
            isRecording = false; 

            const recordingEndTime = performance.now();
            const durationInMs = recordingEndTime - (recordingStartTime || recordingEndTime); 
            const durationInSeconds = Math.round(durationInMs / 1000);
            console.log(`[onstop] 녹음된 오디오 길이 (추정): ${durationInSeconds}초`);

            if (audioChunks.length === 0) { 
                disableTalkButton(false, "녹음 데이터 없음"); 
                resetSilenceTimer(); return; 
            }
            const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType }); 
            audioChunks = [];
            disableTalkButton(true, "STT 처리 중");
            try {
                const userText = await getSTTFromAudio(audioBlob, durationInSeconds); 
                
                if (userText && userText.trim() !== "") {
                    appendMessage(userText, 'user'); 
                    await handleUserInteraction(userText); 
                } else {
                    const noSttMsg = "죄송해요, 잘 알아듣지 못했어요."; 
                    const errorBubble = appendMessage(noSttMsg, 'ai', true);
                    if(errorBubble) chatWindow.appendChild(errorBubble);
                    try { await playTTSFromText(noSttMsg, currentVoiceId); } catch(e){}
                    disableTalkButton(false, "STT 결과 없음"); 
                    resetSilenceTimer();
                }
            } catch (sttError) {
                console.error("[onstop] STT 처리 중 예외:", sttError);
                const sttErrorMsg = "음성 인식 중 오류가 발생했어요."; 
                const errorBubble = appendMessage(sttErrorMsg, 'ai', true);
                if(errorBubble) chatWindow.appendChild(errorBubble);
                try { await playTTSFromText(sttErrorMsg, currentVoiceId); } catch(e){}
                disableTalkButton(false, "STT 오류"); 
                resetSilenceTimer();
            }
        };
        mediaRecorder.start(); 
        resetSilenceTimer();
      } catch (error) {
        console.error("[startRecording] 녹음 시작 중 예외:", error);
        let message = "마이크를 시작할 수 없어요. ";
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") message += "마이크 사용 권한을 허용해주세요.";
        else if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") message += "연결된 마이크 장치를 찾을 수 없어요.";
        else message += `오류: ${error.message}`;
        const errorBubble = appendMessage(message, 'ai', true); 
        if(errorBubble) chatWindow.appendChild(errorBubble);
        try { await playTTSFromText(message, currentVoiceId); } catch(e){}
        isRecording = false; 
        talkBtn.classList.remove('active'); 
        talkBtn.innerHTML = '🎤';
        disableTalkButton(false, "녹음 시작 오류");
      }
    }

    function stopRecording() {
        console.log("[stopRecording] 녹음 중지 요청...");
        if (mediaRecorder && mediaRecorder.state === "recording") { 
            mediaRecorder.stop(); 
        } else { 
            isRecording = false; 
            talkBtn.classList.remove('active'); 
            talkBtn.innerHTML = '🎤';
            disableTalkButton(false, "녹음 중지됨 (수동)");
        }
        if (mediaStream) { 
            mediaStream.getTracks().forEach(track => track.stop()); 
            mediaStream = null; 
        }
    }

    talkBtn.addEventListener('click', async () => {
      console.log("[talkBtn Click] 현재 녹음 상태:", isRecording, "첫 상호작용 완료:", firstInteractionDone);
      
      waitingOverlay.style.display = 'none'; // 마이크 버튼 클릭 시 기다리는 중 오버레이 숨김

      if (!firstInteractionDone && !onboardingComplete) { 
        firstInteractionDone = true; 
        disableTalkButton(true, "초기 인사말 TTS 중");
        loadingIndicatorTalk.style.display = 'block';
        if (initialGreetingText) {
          try {
            await playTTSFromText(initialGreetingText, currentVoiceId);
          } catch (error) {
            if (error.name === 'NotAllowedError') { 
              appendMessage("(목소리를 들으려면 화면을 다시 한번 클릭하거나 마이크 버튼을 눌러주세요.)", "ai", true);
            } else {
              appendMessage("(초기 안내 음성 재생 중 문제가 발생했습니다.)", "ai", true);
            }
          } finally {
            loadingIndicatorTalk.style.display = 'none';
            disableTalkButton(false, "초기 인사말 TTS 완료/실패");
            resetSilenceTimer();
          }
        } else { 
          loadingIndicatorTalk.style.display = 'none';
          disableTalkButton(false, "초기 인사말 없음");
          resetSilenceTimer();
        }
        return; 
      }

      if (!isRecording) {
        startRecording();
      } else {
        stopRecording(); 
      }
    });
    
    // 기다리는 중 오버레이 클릭 시 숨김
    waitingOverlay.addEventListener('click', () => {
        waitingOverlay.style.display = 'none';
        resetSilenceTimer(); // 타이머 다시 시작
    });

    async function initializeChat() {
      disableTalkButton(true, "초기화 중");
      console.log("채팅 초기화 시작...");

      if (!currentUserId || !currentVoiceId) {
          const errorMsg = "사용자 정보(ID 또는 목소리)가 없어 채팅을 시작할 수 없습니다. 설정 또는 시작 페이지로 이동해주세요.";
          console.error("[initializeChat]", errorMsg); 
          const errorBubble = appendMessage(errorMsg, 'ai', true);
          if(errorBubble) chatWindow.appendChild(errorBubble);
          loadingIndicatorTalk.style.display = 'none'; 
          disableTalkButton(true, "사용자 정보 없음");
          return;
      }

      try {
        // ★★★ 온보딩 완료 및 사용자가 intro.html에서 첫마디를 입력한 경우 ★★★
        if (onboardingComplete && userTypedIntro) { 
            console.log("온보딩 완료됨. 사용자가 intro.html에서 입력한 첫마디와 감정으로 대화 시작.");
            appendMessage(userTypedIntro, 'user'); // 사용자의 첫마디를 채팅창에 표시

            const contextForFirstInteraction = { 
                initialUserMessage: userTypedIntro, 
                initialUserEmotions: selectedEmotions, 
                isFirstChatAfterOnboarding: true 
            };
            await handleUserInteraction(userTypedIntro, contextForFirstInteraction);
            
            localStorage.removeItem('lozee_onboarding_complete'); 
            localStorage.removeItem('lozee_user_typed_intro'); // 사용한 intro 메시지 제거
            localStorage.removeItem('lozee_selected_emotions');
            firstInteractionDone = true; 

        } else if (onboardingComplete && !userTypedIntro) { // ★★★ 온보딩은 완료했으나, intro.html에서 첫마디 입력 없이 넘어온 경우 ★★★
            console.log("온보딩 완료됨. 사용자의 첫 음성 입력을 기다립니다.");
            // 로지의 첫인사 (예: "만나서 반가워요, [이름]님! 오늘 어떤 이야기를 나누고 싶으세요?")
            // 이 부분은 getInitialGreeting을 사용하거나, 새로운 첫인사 로직을 만들 수 있습니다.
            // 여기서는 사용자가 먼저 말하도록 유도하기 위해, 로지의 첫마디 없이 바로 마이크 활성화.
            initialGreetingText = `만나서 반가워요, ${currentUserName}님! 오늘 어떤 이야기를 나누고 싶으세요? 아래 마이크 버튼을 눌러 말씀해주세요.`;
            const aiGreetingBubble = appendMessage(initialGreetingText, 'ai');
            if(aiGreetingBubble) chatWindow.appendChild(aiGreetingBubble);
            
            loadingIndicatorTalk.style.display = 'block';
            try {
                await playTTSFromText(initialGreetingText, currentVoiceId);
            } catch(ttsError){
                console.error("온보딩 후 첫 인사 TTS 오류:", ttsError);
            } finally {
                loadingIndicatorTalk.style.display = 'none';
            }
            disableTalkButton(false, "온보딩 후 첫 음성 입력 대기");
            firstInteractionDone = true; // 이 경우, 첫 마이크 클릭이 바로 녹음 시작이 되도록.

        } else { // 온보딩을 안 했거나, 온보딩 데이터가 없는 경우 (기존 일반 시작 로직)
            const urlParams = new URLSearchParams(window.location.search);
            const topicFromUrl = urlParams.get('topic');
            if (topicFromUrl) { 
              const userMsg = `"${topicFromUrl}"에 대해 이야기하고 싶어요.`; 
              appendMessage(userMsg, 'user');
              await handleUserInteraction(`"${topicFromUrl}" 관련해서 이야기 시작해줘.`);
              firstInteractionDone = true; 
            } else { 
              initialGreetingText = await getInitialGreeting(currentUserName, hasVisited, lastSummary, currentUserAge, currentUserDisease);
              const aiGreetingBubble = appendMessage(initialGreetingText, 'ai');
              if(aiGreetingBubble) chatWindow.appendChild(aiGreetingBubble);
              disableTalkButton(false, "초기화 완료, 첫 클릭 대기"); 
            }
        }
        if (!hasVisited) { 
            localStorage.setItem('lozee_hasVisited', 'true'); 
            hasVisited = true; 
        }
      } catch (error) {
          console.error("[initializeChat] 초기화 중 예외:", error);
          const errorBubble = appendMessage("채팅 시작 중 문제가 발생했어요. 페이지를 새로고침 해보세요.", 'ai', true);
          if(errorBubble) chatWindow.appendChild(errorBubble);
          disableTalkButton(true, "초기화 오류");
      } finally {
        console.log("채팅 초기화 완료.");
        resetSilenceTimer(); 
      }
    }
    initializeChat();
  </script>
</body>
</html>
