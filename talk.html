<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LOZEE와 대화</title>
  <link rel="stylesheet" href="style.css"> <link href="https://fonts.googleapis.com/css2?family=KoPub+World+Dotum:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* 기본 페이지 및 폰트 스타일 */
    body { 
      display: flex; 
      flex-direction: column; 
      min-height: 100vh; 
      background-color: #ffffff; 
      color: #333; 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      margin: 0;
    }

    /* 헤더 스타일 */
    #main-header {
      background-color: #0095FF; /* 로지 메인 컬러 */
      color: white;
      padding: 1rem;
      text-align: center;
      font-size: 20px;
      font-weight: bold;
      flex-shrink: 0; 
    }

    /* 채팅 컨테이너 및 창 스타일 */
    #chat-container { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
      overflow-y: hidden; 
      width: 100%; 
      max-width: 700px; 
      margin: 0 auto; 
      box-sizing: border-box; 
    }
    #chat-window { 
      flex: 1; 
      overflow-y: auto; 
      padding: 20px; 
      display: flex; 
      flex-direction: column; 
      gap: 12px; 
    }

    /* 말풍선 공통 스타일 */
    .bubble { 
      max-width: 80%; 
      padding: 12px 18px; 
      border-radius: 20px; 
      line-height: 1.6; 
      font-size: 16px; 
      white-space: pre-wrap; 
      box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
    }
    .user { 
      background-color: #fff9c4; 
      color: #333; 
      align-self: flex-end; 
      margin-left: auto; 
      border-bottom-right-radius: 5px; 
    }
    .ai { 
      background-color: #0095FF; 
      color: white; 
      align-self: flex-start; 
      margin-right: auto; 
      border-bottom-left-radius: 5px; 
    }
    .bubble.ai.error { 
      background-color: #ff7373; 
      color: white; 
    }

    /* 로딩 인디케이터 스타일 */
    #loading-indicator-talk { 
      text-align: center; 
      padding: 10px; 
      display: none; 
      color: #555; 
      font-style: italic; 
    }

    /* 하단 마이크 버튼 컨테이너 스타일 */
    #talk-btn-container { 
      padding: 15px 0; 
      background-color: #ffffff; 
      flex-shrink: 0; 
      text-align: center; 
      border-top: 1px solid #eee; 
    }
    #talk-btn { 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      width: 80px; 
      height: 80px; 
      border-radius: 50%; 
      background-color: #b6b6b6; /* Default grey */
      border: none; 
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); 
      color: white; 
      font-size: 36px; 
      cursor: pointer; 
      display: inline-flex; 
      justify-content: center; 
      align-items: center; 
      transition: transform 0.2s ease, background-color 0.3s; 
    }
    #talk-btn.active { /* Blue state - for continuable or initial active pulse */
      background-color: #0095FF; 
      transform: scale(1.1); 
    }
    #talk-btn.recording-in-progress { /* Red state - for 0-25s recording */
        background-color: #e06c75; /* Softer red */
        transform: scale(1.1); 
    }
    #talk-btn:disabled { 
      background-color: #ccc; 
      cursor: not-allowed; 
      transform: scale(1.0); 
    }

    /* 주제 선택 박스 관련 스타일 (기존과 동일) */
    #topic-selection { display: none; background: #f0f0f0; padding: 20px; border-top: 1px solid #ddd; text-align: center; flex-shrink: 0; }
    #topic-selection h3 { font-size: 18px; color: #333; margin-top: 0; margin-bottom: 15px; font-weight: bold; }
    .topic-option { font-family: 'KoPubWorld Dotum', sans-serif; padding: 10px 15px; margin: 8px auto; background: white; border: 1px solid #0095FF; color: #0095FF; border-radius: 10px; cursor: pointer; max-width: 320px; font-size: 15px; font-weight: bold; transition: background-color 0.2s, color 0.2s; }
    .topic-option:hover { background-color: #0095FF; color: white; }

    /* 기다리는 중 오버레이 스타일 (기존과 동일) */
    #waiting-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8);  display: none;  justify-content: center; align-items: center; z-index: 1000;  color: white; font-size: 24px; font-weight: bold; text-align: center; cursor: pointer;  }
  </style>
</head>
<body>
  <header id="main-header">LOZEE와 대화하기</header>

  <div id="chat-container">
    <div id="chat-window">
      </div>
    <div id="topic-selection">
      <h3>이야기를 이어가고 싶은 주제를 골라볼래?</h3>
      <div id="topic-options">
        </div>
    </div>
  </div>

  <div id="loading-indicator-talk">AI 응답 준비 중...</div>
  
  <div id="talk-btn-container">
    <button id="talk-btn" aria-label="말하기">🎤</button>
  </div>

  <div id="waiting-overlay">
    <p><span id="waitingUserName"></span>님, 잠시 기다리는 중...<br><small>(화면을 클릭하면 다시 시작할 수 있어요)</small></p>
  </div>

  <script type="module">
    import { playTTSFromText } from './js/tts.js';
    import { getSTTFromAudio } from './js/stt.js';
    import { getGptResponse, getInitialGreeting } from './js/gpt-dialog.js';

    console.log("talk.html 스크립트 시작 (v3.14 - 초기화 로깅 강화 및 GPT 간결화)");

    const talkBtn = document.getElementById('talk-btn');
    const chatWindow = document.getElementById('chat-window');
    const topicBox = document.getElementById('topic-selection');
    const topicOptionsContainer = document.getElementById('topic-options');
    const loadingIndicatorTalk = document.getElementById('loading-indicator-talk');
    const waitingOverlay = document.getElementById('waiting-overlay');
    const waitingUserName = document.getElementById('waitingUserName');

    // localStorage 값 가져오기
    const currentUserName = localStorage.getItem('lozee_username') || "친구";
    const currentUserId = localStorage.getItem('lozee_username'); 
    const currentVoiceId = localStorage.getItem('lozee_voice');
    const currentUserAge = localStorage.getItem('lozee_userage');
    const currentUserDisease = localStorage.getItem('lozee_userdiagnosis');
    let hasVisited = localStorage.getItem('lozee_hasVisited') === 'true';
    let lastSummary = localStorage.getItem('lozee_lastSummary') || '';

    // 온보딩 관련 값
    const onboardingComplete = localStorage.getItem('lozee_onboarding_complete') === 'true';
    const userTypedIntro = localStorage.getItem('lozee_user_typed_intro'); 
    const selectedEmotionsString = localStorage.getItem('lozee_selected_emotions');
    let selectedEmotions = [];
    if (selectedEmotionsString) {
        try {
            selectedEmotions = JSON.parse(selectedEmotionsString);
        } catch (e) {
            console.error("선택된 감정 localStorage 파싱 오류:", e);
            selectedEmotions = []; // 파싱 실패 시 빈 배열로 초기화
        }
    }

    // GPT 응답 간결화 로직 (스크립트 상단에서 정의)
    const simplified = (() => {
      const age = parseInt(currentUserAge || "0", 10);
      const disease = (currentUserDisease || "").toLowerCase();
      const needsSimple = age < 15 || ["아스퍼거", "asd", "adhd", "사회적의사소통장애"].some(d => disease.includes(d));
      const isVeryYoung = age < 10;
      console.log(`[Simplified Language Check] Age: ${age}, Disease: "${disease}", NeedsSimple: ${needsSimple}, IsVeryYoung: ${isVeryYoung}`);
      return { useSimpleLanguage: needsSimple, useUltraSimpleLanguage: isVeryYoung };
    })();

    // 나머지 전역 변수들
    let isRecording = false;
    let mediaRecorder;
    let audioChunks = [];
    let mediaStream = null;
    let silenceTimer;
    const SILENCE_TIMEOUT = 20000; 
    let firstInteractionDone = false; 
    let initialGreetingText = "";    
    let recordingStartTimeValue; 

    const ADMIN_SECRET_PHRASE = "고양이맹구름맹누리";
    const ADMIN_EMAIL = "maengnanyoung@gmail.com";

    let totalCharacterCount = 0;
    let conversationStartTime = null;
    const ANALYSIS_CHAR_THRESHOLD = 800; 
    const ANALYSIS_TIME_THRESHOLD_SECONDS = 180; 
    let analysisRedirectInProgress = false;

    const MAX_RECORDING_DURATION_MS = 30000; 
    const CONTINUE_THRESHOLD_MS = 25000;     
    const MAX_CONSECUTIVE_SEGMENTS = 5;      
    let currentSegmentCount = 0;             
    let autoStopTimer = null;                
    let continuePromptTimer = null;          
    let isEligibleToContinue = false;        
    let userClickedToContinue = false;       
    const API_DISCONNECT_DELAY_MS = 1000;

    function appendMessage(text, role = 'ai', isError = false) {
      // (기존과 동일 - AI 메시지는 호출부에서 chatWindow에 추가)
      if (!text || String(text).trim() === "") { return null; }
      const messageText = String(text);
      console.log(`[appendMessage] (${role}): ${messageText.substring(0,30)}...`);
      totalCharacterCount += messageText.length; 
      const msgDiv = document.createElement('div'); 
      msgDiv.className = `bubble ${role}`;
      if (isError && role === 'ai') msgDiv.classList.add('error');
      msgDiv.innerHTML = messageText.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank">$1</a>');
      if (role === 'user') { 
            chatWindow.appendChild(msgDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;
            resetSilenceTimer();
      }
      return msgDiv; 
    }

    function disableTalkButton(disable = true, reason = "") {
      talkBtn.disabled = disable;
      console.log(`[disableTalkButton] ${disable ? '비활성화' : '활성화'}${reason ? ` (${reason})` : ''}`);
    }

    async function loadRecentTopics() { /* (기존과 동일) */ 
      if (!currentUserId) { console.warn("[loadRecentTopics] 사용자 ID 없음, 주제 로드 건너뜀."); return []; }
      try {
        const backendUrl = 'https://ggg-production.up.railway.app'; 
        const response = await fetch(`${backendUrl}/api/topics?userId=${encodeURIComponent(currentUserId)}`);
        if (!response.ok) { console.error(`[loadRecentTopics] 최근 주제 불러오기 실패: ${response.status} - ${await response.text()}`); return []; }
        const data = await response.json(); return data.topics || [];
      } catch (error) { console.error('[loadRecentTopics] 최근 주제 불러오기 중 오류:', error); return []; }
    }

    function showTopicBox(topics) { /* (기존과 동일 - AI 메시지 추가 로직은 appendMessage 호출부에서 처리) */ 
        topicOptionsContainer.innerHTML = ''; 
        let hasOptions = false;
        if (topics && topics.length > 0) { 
            topics.slice(0, 3).forEach(topic => {
                const option = document.createElement('div'); option.className = 'topic-option';
                option.textContent = topic;
                option.onclick = () => {
                    topicBox.style.display = 'none';
                    appendMessage(`"${topic}"(으)로 대화를 이어갈게요.`, 'user');
                    handleUserInteraction(`"${topic}"에 대해 이어서 이야기 해줘.`);
                };
                topicOptionsContainer.appendChild(option); hasOptions = true;
            });
        } else { 
            const option1 = document.createElement('div'); option1.className = 'topic-option';
            option1.textContent = "조금 이따가 이야기 할까요?";
            option1.onclick = () => {
                topicBox.style.display = 'none'; waitingUserName.textContent = currentUserName;
                waitingOverlay.style.display = 'flex';
                const waitingMsgDiv = appendMessage("(로지가 잠시 기다리고 있어요. 언제든 다시 화면을 클릭하거나 말을 걸어주세요.)", "ai", true);
                if (waitingMsgDiv) chatWindow.appendChild(waitingMsgDiv); clearTimeout(silenceTimer); 
            };
            topicOptionsContainer.appendChild(option1);
            const option2 = document.createElement('div'); option2.className = 'topic-option';
            option2.textContent = "다른 주제에 대해 물어봐도 될까요?";
            option2.onclick = () => {
                topicBox.style.display = 'none'; appendMessage("다른 주제에 대해 물어봐도 될까요?", 'user'); 
                handleUserInteraction("가족에 대해 이야기 해 줄 수 있어?"); 
            };
            topicOptionsContainer.appendChild(option2); hasOptions = true;
        }
        topicBox.style.display = hasOptions ? 'block' : 'none'; 
        if(hasOptions) setTimeout(() => chatWindow.scrollTop = chatWindow.scrollHeight, 0); 
    }

    function startSilenceTimer() { /* (기존과 동일 - 예외 처리 추가) */ 
        clearTimeout(silenceTimer); 
        silenceTimer = setTimeout(async () => {
            if (isRecording || analysisRedirectInProgress) { return; }
            try {
                const topics = await loadRecentTopics(); showTopicBox(topics);
            } catch (error) { console.error("[Timer] 최근 주제 불러오기 중 오류 발생 (침묵 타이머):", error); }
        }, SILENCE_TIMEOUT);
    }

    function resetSilenceTimer() { /* (기존과 동일) */ 
        clearTimeout(silenceTimer);
        if (topicBox.style.display === 'none' && talkBtn.disabled === false && !analysisRedirectInProgress) {
            startSilenceTimer();
        }
    }
    
    function checkAndRedirectToAnalysis() { /* (기존과 동일 - AI 메시지 추가 로직은 appendMessage 호출부에서 처리) */ 
        if (analysisRedirectInProgress || !conversationStartTime) return;
        const durationInSeconds = (Date.now() - conversationStartTime) / 1000;
        if (totalCharacterCount >= ANALYSIS_CHAR_THRESHOLD && durationInSeconds >= ANALYSIS_TIME_THRESHOLD_SECONDS) {
            analysisRedirectInProgress = true; disableTalkButton(true, "분석 페이지 이동 준비 중");
            const redirectMsgDiv = appendMessage("(대화 내용이 충분하여 분석 페이지로 이동합니다...)", "ai", true);
            if (redirectMsgDiv) chatWindow.appendChild(redirectMsgDiv);
            setTimeout(() => { window.location.href = 'analysis.html'; }, 2000);
        }
    }

    async function handleUserInteraction(userText, context = {}) { /* (기존과 동일 - GPT 컨텍스트 및 AI 메시지 추가 로직 수정됨) */ 
      if (!userText || userText.trim() === "" || analysisRedirectInProgress) return;
      if (!conversationStartTime) conversationStartTime = Date.now();
      disableTalkButton(true, "AI 응답 대기 중"); topicBox.style.display = 'none'; loadingIndicatorTalk.style.display = 'block';
      const gptContext = { userAge: currentUserAge, userDisease: currentUserDisease, useSimpleLanguage: simplified.useSimpleLanguage, useUltraSimpleLanguage: simplified.useUltraSimpleLanguage, ...context };
      console.log("[handleUserInteraction] GPT Context:", gptContext);
      try {
        const gptResponse = await getGptResponse(userText, currentUserId, gptContext);
        let aiReply = gptResponse?.rephrasing || gptResponse?.error || "죄송해요, 답변을 이해하는 데 어려움이 있었어요.";
        let isError = !gptResponse?.rephrasing;
        if (gptResponse?.summary) localStorage.setItem('lozee_lastSummary', (lastSummary = gptResponse.summary));
        setTimeout(async () => {
            loadingIndicatorTalk.style.display = 'none'; 
            const aiBubbleDiv = appendMessage(aiReply, 'ai', isError); 
            if (aiBubbleDiv) { chatWindow.appendChild(aiBubbleDiv); chatWindow.scrollTop = chatWindow.scrollHeight; }
            if (!analysisRedirectInProgress) { try { await playTTSFromText(aiReply, currentVoiceId); } catch (e) { console.error("TTS 실패:", e); } }
            if (!analysisRedirectInProgress) { disableTalkButton(false, "AI 응답 완료"); resetSilenceTimer(); checkAndRedirectToAnalysis(); }
        }, 1000);
      } catch (error) { 
        loadingIndicatorTalk.style.display = 'none';
        const fallbackMsg = "죄송합니다, 응답 처리 중 예상치 못한 문제가 발생했어요.";
        const errorBubble = appendMessage(fallbackMsg, 'ai', true);
        if(errorBubble) chatWindow.appendChild(errorBubble);
        if (!analysisRedirectInProgress) {
            try { await playTTSFromText(fallbackMsg, currentVoiceId); } catch (e) { console.error("TTS 실패 (오류 처리 중):", e); }
            disableTalkButton(false, "AI 응답 오류"); resetSilenceTimer(); 
        }
      } 
    }

    async function startRecording() { /* (기존과 동일 - AI 메시지 추가 로직은 appendMessage 호출부에서 처리) */ 
      if (isRecording || analysisRedirectInProgress) { return; }
      if (currentSegmentCount >= MAX_CONSECUTIVE_SEGMENTS) {
          const maxReachedMsgDiv = appendMessage(`최대 ${MAX_CONSECUTIVE_SEGMENTS}번까지 연속으로 말할 수 있습니다. 다시 녹음을 시작하려면 마이크 버튼을 눌러주세요.`, "ai", true);
          if (maxReachedMsgDiv) chatWindow.appendChild(maxReachedMsgDiv); 
          try { await playTTSFromText(maxReachedMsgDiv.textContent, currentVoiceId); } catch(e) { console.error("Max segments TTS error:", e); }
          talkBtn.innerHTML = '🎤'; talkBtn.classList.remove('active', 'recording-in-progress');
          disableTalkButton(false, "최대 연속 녹음 도달"); currentSegmentCount = 0; isRecording = false; 
          return;
      }
      currentSegmentCount++; console.log(`[startRecording] Segment ${currentSegmentCount}/${MAX_CONSECUTIVE_SEGMENTS} 시작`);
      topicBox.style.display = 'none'; waitingOverlay.style.display = 'none'; 
      try {
        if (mediaStream) { mediaStream.getTracks().forEach(track => track.stop()); mediaStream = null; }
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true }); 
        isRecording = true; isEligibleToContinue = false; userClickedToContinue = false; 
        talkBtn.classList.remove('active'); talkBtn.classList.add('recording-in-progress'); talkBtn.innerHTML = '⏹️'; 
        disableTalkButton(false, "녹음 중"); 
        audioChunks = []; const options = { mimeType: 'audio/webm;codecs=opus' };
        mediaRecorder = new MediaRecorder(mediaStream, options); recordingStartTimeValue = performance.now(); 
        mediaRecorder.ondataavailable = event => { if (event.data.size > 0) { audioChunks.push(event.data); } };
        mediaRecorder.onstop = async () => {
            isRecording = false; 
            const durationInSeconds = Math.round((performance.now() - (recordingStartTimeValue || performance.now())) / 1000);
            console.log(`[onstop] 녹음된 오디오 길이 (추정): ${durationInSeconds}초, 세그먼트: ${currentSegmentCount}`);
            if (audioChunks.length === 0 && !userClickedToContinue) { /* ... */ return; }
            const audioBlob = (audioChunks.length > 0) ? new Blob(audioChunks, { type: mediaRecorder.mimeType }) : null;
            audioChunks = [];
            if (!analysisRedirectInProgress) disableTalkButton(true, "STT 처리 중");
            try {
                const userText = audioBlob ? await getSTTFromAudio(audioBlob, durationInSeconds) : "";
                if (userText && userText.trim() !== "") { /* ... handle user text ... */ } 
                else if (!userClickedToContinue && audioBlob) { 
                    const noSttMsgDiv = appendMessage("죄송해요, 잘 알아듣지 못했어요.", 'ai', true);
                    if (noSttMsgDiv) chatWindow.appendChild(noSttMsgDiv);
                    if (!analysisRedirectInProgress) try {await playTTSFromText(noSttMsgDiv.textContent, currentVoiceId); } catch(e) {/*...*/}
                }
            } catch (sttError) { 
                const sttErrorMsgDiv = appendMessage("음성 인식 중 오류가 발생했어요.", 'ai', true);
                if (sttErrorMsgDiv) chatWindow.appendChild(sttErrorMsgDiv);
                if (!analysisRedirectInProgress) try {await playTTSFromText(sttErrorMsgDiv.textContent, currentVoiceId); } catch(e) {/*...*/}
            } finally {
                const shouldContinueChain = userClickedToContinue && currentSegmentCount < MAX_CONSECUTIVE_SEGMENTS;
                userClickedToContinue = false; 
                if (shouldContinueChain) {
                    if (mediaStream) { mediaStream.getTracks().forEach(track => track.stop()); mediaStream = null; }
                    mediaRecorder = null; disableTalkButton(true, "다음 녹음 준비 중..."); 
                    setTimeout(() => { if (!analysisRedirectInProgress) startRecording(); else { /* ... */ } }, API_DISCONNECT_DELAY_MS);
                } else { /* ... reset chain ... */ }
            }
        };
        mediaRecorder.start(); 
        clearTimeout(autoStopTimer); autoStopTimer = setTimeout(() => { if (isRecording && mediaRecorder.state === "recording") { userClickedToContinue = false; stopRecording(); } }, MAX_RECORDING_DURATION_MS);
        clearTimeout(continuePromptTimer); continuePromptTimer = setTimeout(() => { if (isRecording) { isEligibleToContinue = true; talkBtn.classList.remove('recording-in-progress'); talkBtn.classList.add('active'); } }, CONTINUE_THRESHOLD_MS);
        resetSilenceTimer();
      } catch (error) { /* ... error handling ... */ 
            const errorMsgDiv = appendMessage("마이크를 시작할 수 없어요. 권한을 확인해주세요.", 'ai', true);
            if (errorMsgDiv) chatWindow.appendChild(errorMsgDiv);
            /* ... */
        }
    }

    function stopRecording() { /* (기존과 동일) */ 
        clearTimeout(autoStopTimer); autoStopTimer = null; clearTimeout(continuePromptTimer); continuePromptTimer = null;
        isEligibleToContinue = false; 
        if (mediaRecorder && mediaRecorder.state === "recording") { mediaRecorder.stop(); } else { isRecording = false; }
    }

    talkBtn.addEventListener('click', async () => { /* (기존과 동일 - AI 메시지 추가 로직은 appendMessage 호출부에서 처리) */ 
      if (analysisRedirectInProgress) { return; }
      waitingOverlay.style.display = 'none'; 
      if (!firstInteractionDone && !onboardingComplete && initialGreetingText) { 
        firstInteractionDone = true; disableTalkButton(true, "초기 인사말 TTS 중"); loadingIndicatorTalk.style.display = 'block';
        try { await playTTSFromText(initialGreetingText, currentVoiceId); } 
        catch (error) {
          const errorBubble = appendMessage( error.name === 'NotAllowedError' ? "(목소리를 들으려면 화면을 다시 한번 클릭하거나 마이크 버튼을 눌러주세요.)" : "(초기 안내 음성 재생 중 문제가 발생했습니다.)", "ai", true);
          if(errorBubble) chatWindow.appendChild(errorBubble); 
        } finally { loadingIndicatorTalk.style.display = 'none'; disableTalkButton(false, "초기 인사말 TTS 완료/실패"); resetSilenceTimer(); }
        return; 
      }
      if (!isRecording) { currentSegmentCount = 0; userClickedToContinue = false; isEligibleToContinue = false; startRecording(); } 
      else { userClickedToContinue = isEligibleToContinue && currentSegmentCount < MAX_CONSECUTIVE_SEGMENTS; stopRecording(); }
    });
    
    waitingOverlay.addEventListener('click', () => { /* (기존과 동일) */ });

    async function initializeChat() { 
      talkBtn.innerHTML = '🎤';
      talkBtn.classList.remove('active', 'recording-in-progress');
      disableTalkButton(true, "초기화 중");
      console.log("--- 채팅 초기화 시작 ---");
      console.log("[INIT_LOG] localStorage 값 확인:");
      console.log(`[INIT_LOG] currentUserName: "${currentUserName}" (원본: "${localStorage.getItem('lozee_username')}")`);
      console.log(`[INIT_LOG] currentUserId: "${currentUserId}" (원본: "${localStorage.getItem('lozee_username')}")`);
      console.log(`[INIT_LOG] currentVoiceId: "${currentVoiceId}" (원본: "${localStorage.getItem('lozee_voice')}")`);
      console.log(`[INIT_LOG] currentUserAge: "${currentUserAge}" (원본: "${localStorage.getItem('lozee_userage')}")`);
      console.log(`[INIT_LOG] currentUserDisease: "${currentUserDisease}" (원본: "${localStorage.getItem('lozee_userdiagnosis')}")`);
      console.log(`[INIT_LOG] hasVisited: ${hasVisited}`);
      console.log(`[INIT_LOG] onboardingComplete: ${onboardingComplete}, userTypedIntro: "${userTypedIntro}"`);

      if (!currentUserId || !currentVoiceId) { 
          const errorMsg = `필수 사용자 정보(ID 또는 목소리)가 없어 대화를 시작할 수 없습니다. [ID: ${currentUserId}, Voice: ${currentVoiceId}] 설정 페이지로 돌아가거나 앱을 다시 시작해주세요.`;
          console.error("[initializeChat] 치명적 오류:", errorMsg); 
          const errorBubble = appendMessage(errorMsg, 'ai', true);
          if(errorBubble) chatWindow.appendChild(errorBubble);
          loadingIndicatorTalk.style.display = 'none'; 
          disableTalkButton(true, "사용자 정보 없음 (필수 값 누락)"); // 버튼 비활성화 유지
          console.log("--- 채팅 초기화 중단 (필수 정보 누락) ---");
          return;
      }

      console.log("[INIT_LOG] 필수 사용자 정보 (ID, Voice) 확인 완료.");

      try {
        if (onboardingComplete && userTypedIntro) { 
            console.log("[INIT_LOG] 케이스 1: 온보딩 완료, 사용자 첫마디 입력됨.");
            appendMessage(userTypedIntro, 'user'); 
            if (!conversationStartTime) conversationStartTime = Date.now();
            await handleUserInteraction(userTypedIntro, { initialUserMessage: userTypedIntro, initialUserEmotions: selectedEmotions, isFirstChatAfterOnboarding: true });
            localStorage.removeItem('lozee_onboarding_complete'); 
            localStorage.removeItem('lozee_user_typed_intro'); 
            firstInteractionDone = true; 
        } else if (onboardingComplete && !userTypedIntro) { 
            console.log("[INIT_LOG] 케이스 2: 온보딩 완료, 사용자 첫 음성 입력 대기.");
            initialGreetingText = `만나서 반가워요, ${currentUserName}님! 이제 대화를 시작할 준비가 되었어요. 아래 마이크 버튼을 눌러 지금 어떤지 말씀해주세요.`;
            console.log(`[INIT_LOG] 생성된 초기 인사말 (케이스 2): "${initialGreetingText}"`);
            const aiGreetingBubble = appendMessage(initialGreetingText, 'ai');
            if(aiGreetingBubble) chatWindow.appendChild(aiGreetingBubble);
            loadingIndicatorTalk.style.display = 'block';
            try { await playTTSFromText(initialGreetingText, currentVoiceId); } catch(e) { console.error("온보딩 후 첫 인사 TTS 오류:", e); } 
            finally { loadingIndicatorTalk.style.display = 'none'; }
            disableTalkButton(false, "온보딩 후 첫 음성 입력 대기");
            firstInteractionDone = true; 
        } else { 
            const urlParams = new URLSearchParams(window.location.search);
            const topicFromUrl = urlParams.get('topic');
            if (topicFromUrl) { 
              console.log(`[INIT_LOG] 케이스 3: URL에서 토픽 가져옴 ("${topicFromUrl}").`);
              const userMsg = `"${topicFromUrl}"에 대해 이야기하고 싶어요.`; 
              appendMessage(userMsg, 'user');
              if (!conversationStartTime) conversationStartTime = Date.now();
              await handleUserInteraction(`"${topicFromUrl}" 관련해서 이야기 시작해줘.`);
              firstInteractionDone = true; 
            } else { 
              console.log("[INIT_LOG] 케이스 4: 일반 시작 (첫 방문 또는 재방문).");
              initialGreetingText = await getInitialGreeting(currentUserName, hasVisited, lastSummary, currentUserAge, currentUserDisease);
              console.log(`[INIT_LOG] getInitialGreeting 반환 값: "${initialGreetingText}"`);
              if (!initialGreetingText || initialGreetingText.trim() === "") {
                  console.warn("[INIT_LOG] getInitialGreeting이 비어있는 문자열 또는 null을 반환했습니다. 기본 인사말로 대체합니다.");
                  initialGreetingText = `${currentUserName}님, 안녕하세요! 어떤 이야기를 나누고 싶으신가요?`;
              }
              const aiGreetingBubble = appendMessage(initialGreetingText, 'ai');
              if(aiGreetingBubble) chatWindow.appendChild(aiGreetingBubble);
              disableTalkButton(false, "초기화 완료, 첫 클릭 대기"); 
            }
        }
        if (!hasVisited) { 
            localStorage.setItem('lozee_hasVisited', 'true'); 
            hasVisited = true; 
            console.log("[INIT_LOG] 첫 방문으로 기록됨 (lozee_hasVisited = true).");
        }
      } catch (error) { 
          console.error("[initializeChat] 초기화 중 예외 발생:", error);
          const errorBubble = appendMessage("채팅 시작 중 문제가 발생했어요. 페이지를 새로고침 해보세요.", 'ai', true);
          if(errorBubble) chatWindow.appendChild(errorBubble);
          disableTalkButton(true, "초기화 오류");
      } finally {
        console.log("--- 채팅 초기화 완료 ---");
        if (!analysisRedirectInProgress) resetSilenceTimer(); 
      }
    }
    initializeChat();
  </script>
</body>
</html>
