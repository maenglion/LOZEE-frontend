<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LOZEEì™€ ëŒ€í™”</title>
  <link rel="stylesheet" href="style.css"> <link href="https://fonts.googleapis.com/css2?family=KoPub+World+Dotum:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* ê¸°ë³¸ í˜ì´ì§€ ë° í°íŠ¸ ìŠ¤íƒ€ì¼ */
    body { 
      display: flex; 
      flex-direction: column; 
      min-height: 100vh; 
      background-color: #ffffff; 
      color: #333; 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      margin: 0;
    }

    /* í—¤ë” ìŠ¤íƒ€ì¼ */
    #main-header {
      background-color: #0095FF; /* ë¡œì§€ ë©”ì¸ ì»¬ëŸ¬ */
      color: white;
      padding: 1rem;
      text-align: center;
      font-size: 20px;
      font-weight: bold;
      flex-shrink: 0; 
    }

    /* ì±„íŒ… ì»¨í…Œì´ë„ˆ ë° ì°½ ìŠ¤íƒ€ì¼ */
    #chat-container { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
      overflow-y: hidden; 
      width: 100%; 
      max-width: 700px; 
      margin: 0 auto; 
      box-sizing: border-box; 
    }
    #chat-window { 
      flex: 1; 
      overflow-y: auto; 
      padding: 20px; 
      display: flex; 
      flex-direction: column; 
      gap: 12px; 
    }

    /* ë§í’ì„  ê³µí†µ ìŠ¤íƒ€ì¼ */
    .bubble { 
      max-width: 80%; 
      padding: 12px 18px; 
      border-radius: 20px; 
      line-height: 1.6; 
      font-size: 16px; 
      white-space: pre-wrap; 
      box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
    }
    .user { 
      background-color: #fff9c4; 
      color: #333; 
      align-self: flex-end; 
      margin-left: auto; 
      border-bottom-right-radius: 5px; 
    }
    .ai { 
      background-color: #0095FF; 
      color: white; 
      align-self: flex-start; 
      margin-right: auto; 
      border-bottom-left-radius: 5px; 
    }
    .bubble.ai.error { 
      background-color: #ff7373; 
      color: white; 
    }

    /* ë¡œë”© ì¸ë””ì¼€ì´í„° ìŠ¤íƒ€ì¼ */
    #loading-indicator-talk { 
      text-align: center; 
      padding: 10px; 
      display: none; 
      color: #555; 
      font-style: italic; 
    }

    /* í•˜ë‹¨ ë§ˆì´í¬ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
    #talk-btn-container { 
      padding: 15px 0; 
      background-color: #ffffff; 
      flex-shrink: 0; 
      text-align: center; 
      border-top: 1px solid #eee; 
    }
    #talk-btn { 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      width: 80px; 
      height: 80px; 
      border-radius: 50%; 
      background-color: #b6b6b6; 
      border: none; 
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); 
      color: white; 
      font-size: 36px; 
      cursor: pointer; 
      display: inline-flex; 
      justify-content: center; 
      align-items: center; 
      transition: transform 0.2s ease, background-color 0.3s; 
    }
    #talk-btn.active { 
      background-color: #0095FF; 
      transform: scale(1.1); 
    }
    #talk-btn:disabled { 
      background-color: #ccc; 
      cursor: not-allowed; 
      transform: scale(1.0); 
    }

    /* ì£¼ì œ ì„ íƒ ë°•ìŠ¤ ê´€ë ¨ ìŠ¤íƒ€ì¼ */
    #topic-selection { 
      display: none; 
      background: #f0f0f0; 
      padding: 20px; 
      border-top: 1px solid #ddd; 
      text-align: center; 
      flex-shrink: 0; 
    }
    #topic-selection h3 { 
      font-size: 18px; 
      color: #333; 
      margin-top: 0; 
      margin-bottom: 15px; 
      font-weight: bold; 
    }
    .topic-option { 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      padding: 10px 15px; 
      margin: 8px auto; 
      background: white; 
      border: 1px solid #0095FF; 
      color: #0095FF; 
      border-radius: 10px; 
      cursor: pointer; 
      max-width: 320px; 
      font-size: 15px; 
      font-weight: bold; 
      transition: background-color 0.2s, color 0.2s; 
    }
    .topic-option:hover { 
      background-color: #0095FF; 
      color: white; 
    }

    /* ê¸°ë‹¤ë¦¬ëŠ” ì¤‘ ì˜¤ë²„ë ˆì´ ìŠ¤íƒ€ì¼ */
    #waiting-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8); 
        display: none; 
        justify-content: center;
        align-items: center;
        z-index: 1000; 
        color: white;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        cursor: pointer; 
    }
  </style>
</head>
<body>
  <header id="main-header">LOZEEì™€ ëŒ€í™”í•˜ê¸°</header>

  <div id="chat-container">
    <div id="chat-window">
      </div>
    <div id="topic-selection">
      <h3>ì´ì•¼ê¸°ë¥¼ ì´ì–´ê°€ê³  ì‹¶ì€ ì£¼ì œë¥¼ ê³¨ë¼ë³¼ë˜?</h3>
      <div id="topic-options">
        </div>
    </div>
  </div>

  <div id="loading-indicator-talk">AI ì‘ë‹µ ì¤€ë¹„ ì¤‘...</div>
  
  <div id="talk-btn-container">
    <button id="talk-btn" aria-label="ë§í•˜ê¸°">ğŸ¤</button>
  </div>

  <div id="waiting-overlay">
    <p><span id="waitingUserName"></span>ë‹˜, ì ì‹œ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...<br><small>(í™”ë©´ì„ í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì‹œì‘í•  ìˆ˜ ìˆì–´ìš”)</small></p>
  </div>

  <script type="module">
    import { playTTSFromText } from './js/tts.js';
    import { getSTTFromAudio } from './js/stt.js';
    import { getGptResponse, getInitialGreeting } from './js/gpt-dialog.js';

    console.log("talk.html ìŠ¤í¬ë¦½íŠ¸ ì‹œì‘ (v3.6 - GPT ì‘ë‹µ ë¡œê¹… ë° TTS ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”)");

    const talkBtn = document.getElementById('talk-btn');
    const chatWindow = document.getElementById('chat-window');
    const topicBox = document.getElementById('topic-selection');
    const topicOptionsContainer = document.getElementById('topic-options');
    const loadingIndicatorTalk = document.getElementById('loading-indicator-talk');
    const waitingOverlay = document.getElementById('waiting-overlay');
    const waitingUserName = document.getElementById('waitingUserName');

    const currentUserName = localStorage.getItem('lozee_username') || "ì¹œêµ¬";
    const currentUserId = localStorage.getItem('lozee_username'); 
    const currentVoiceId = localStorage.getItem('lozee_voice');
    const currentUserAge = localStorage.getItem('lozee_userage');
    const currentUserDisease = localStorage.getItem('lozee_userdiagnosis');
    let hasVisited = localStorage.getItem('lozee_hasVisited') === 'true';
    let lastSummary = localStorage.getItem('lozee_lastSummary') || '';

    const onboardingComplete = localStorage.getItem('lozee_onboarding_complete') === 'true';
    const userTypedIntro = localStorage.getItem('lozee_user_typed_intro'); 
    const selectedEmotionsString = localStorage.getItem('lozee_selected_emotions');
    let selectedEmotions = [];
    if (selectedEmotionsString) {
        try {
            selectedEmotions = JSON.parse(selectedEmotionsString);
        } catch (e) {
            console.error("ì„ íƒëœ ê°ì • localStorage íŒŒì‹± ì˜¤ë¥˜:", e);
            selectedEmotions = [];
        }
    }

    console.log("ì‚¬ìš©ì ì •ë³´:", { currentUserName, currentVoiceId, currentUserAge, currentUserDisease, hasVisited });
    console.log("ì˜¨ë³´ë”© ì™„ë£Œ ì—¬ë¶€:", onboardingComplete);
    if(onboardingComplete) {
        console.log("ì˜¨ë³´ë”© ë°ì´í„° -> ì‚¬ìš©ì ì²«ë§ˆë””:", userTypedIntro, "ì„ íƒëœ ê°ì •:", selectedEmotions);
    }

    let isRecording = false;
    let mediaRecorder;
    let audioChunks = [];
    let mediaStream = null;
    let silenceTimer;
    const SILENCE_TIMEOUT = 20000; 
    let firstInteractionDone = false; 
    let initialGreetingText = "";    
    let recordingStartTime; 

    function appendMessage(text, role = 'ai', isError = false) {
      if (!text || String(text).trim() === "") { 
        console.log(`[appendMessage] ë¹ˆ ë©”ì‹œì§€ (${role}), ì¶”ê°€ ì•ˆí•¨.`); 
        return null; 
      }
      console.log(`[appendMessage] (${role}): ${String(text).substring(0,50)}...`);
      const msgDiv = document.createElement('div'); 
      msgDiv.className = `bubble ${role}`;
      if (isError && role === 'ai') msgDiv.classList.add('error');
      const processedText = String(text).replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank">$1</a>');
      msgDiv.innerHTML = processedText; 
      
      if (role === 'user') { 
            chatWindow.appendChild(msgDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;
          
        // --- ë¶„ì„ ì¡°ê±´: ì¼ì • ê¸€ì ìˆ˜ ì´ìƒ + ì‹œê°„ ê²½ê³¼ ---
        const now = Date.now();
        if (!window.__lozeeChatStartTime) window.__lozeeChatStartTime = now;
        if (!window.__lozeeTotalCharCount) window.__lozeeTotalCharCount = 0;

        window.__lozeeTotalCharCount += userText.length + (gptResponse?.rephrasing?.length || 0);

        const timeElapsed = now - window.__lozeeChatStartTime;
        const MAX_CHAR_FOR_ANALYSIS = 1200;
        const MAX_TIME_FOR_ANALYSIS_MS = 300000; // 5ë¶„

        if (window.__lozeeTotalCharCount >= MAX_CHAR_FOR_ANALYSIS || timeElapsed >= MAX_TIME_FOR_ANALYSIS_MS) {
          console.log("[LOZEE] ë¶„ì„ ì¡°ê±´ ì¶©ì¡± - analysis.htmlë¡œ ì´ë™");
          localStorage.setItem("adminOverride", "true");
          setTimeout(() => { window.location.href = 'analysis.html'; }, 800);
        }

        resetSilenceTimer();
          return msgDiv; 
      } else { 
          return msgDiv; 
      }
    }

    function disableTalkButton(disable = true, reason = "") {
      talkBtn.disabled = disable;
      console.log(`[disableTalkButton] ${disable ? 'ë¹„í™œì„±í™”' : 'í™œì„±í™”'}${reason ? ` (${reason})` : ''}`);
    }

    async function loadRecentTopics() {
      if (!currentUserId) { 
        console.warn("[loadRecentTopics] ì‚¬ìš©ì ID ì—†ìŒ, ì£¼ì œ ë¡œë“œ ê±´ë„ˆëœ€.");
        return []; 
      }
      try {
        const backendUrl = 'https://ggg-production.up.railway.app'; 
        console.log(`[loadRecentTopics] ${backendUrl}/api/topics?userId=${encodeURIComponent(currentUserId)} í˜¸ì¶œ ì‹œë„...`);
        const response = await fetch(`${backendUrl}/api/topics?userId=${encodeURIComponent(currentUserId)}`);
        console.log(`[loadRecentTopics] /api/topics ì‘ë‹µ ìƒíƒœ: ${response.status}`);
        if (!response.ok) { 
          const errorText = await response.text(); 
          console.error(`[loadRecentTopics] ìµœê·¼ ì£¼ì œ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${response.status} - ${errorText}`); 
          return []; 
        }
        const data = await response.json(); 
        console.log("[loadRecentTopics] ìµœê·¼ ì£¼ì œ ë°ì´í„°:", data);
        return data.topics || [];
      } catch (error) { 
        console.error('[loadRecentTopics] ìµœê·¼ ì£¼ì œ ë¶ˆëŸ¬ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜:', error); 
        return []; 
      }
    }

    function showTopicBox(topics) {
        topicOptionsContainer.innerHTML = ''; 
        let hasOptions = false;
        console.log("[showTopicBox] ì£¼ì œ ë°•ìŠ¤ í‘œì‹œ ì‹œë„. ë°›ì€ ì£¼ì œ:", topics);

        if (topics && topics.length > 0) { 
            topics.slice(0, 3).forEach(topic => {
                const option = document.createElement('div'); option.className = 'topic-option';
                option.textContent = topic;
                option.onclick = () => {
                    topicBox.style.display = 'none';
                    appendMessage(`"${topic}"(ìœ¼)ë¡œ ëŒ€í™”ë¥¼ ì´ì–´ê°ˆê²Œìš”.`, 'user');
                    handleUserInteraction(`"${topic}"ì— ëŒ€í•´ ì´ì–´ì„œ ì´ì•¼ê¸° í•´ì¤˜.`);
                };
                topicOptionsContainer.appendChild(option); 
                hasOptions = true;
            });
        } else { 
            const option1 = document.createElement('div'); option1.className = 'topic-option';
            option1.textContent = "ì¡°ê¸ˆ ì´ë”°ê°€ ì´ì•¼ê¸° í• ê¹Œìš”?";
            option1.onclick = () => {
                topicBox.style.display = 'none';
                waitingUserName.textContent = currentUserName;
                waitingOverlay.style.display = 'flex';
                const waitingMsgDiv = appendMessage("(ë¡œì§€ê°€ ì ì‹œ ê¸°ë‹¤ë¦¬ê³  ìˆì–´ìš”. ì–¸ì œë“  ë‹¤ì‹œ í™”ë©´ì„ í´ë¦­í•˜ê±°ë‚˜ ë§ì„ ê±¸ì–´ì£¼ì„¸ìš”.)", "ai", true);
                if (waitingMsgDiv) chatWindow.appendChild(waitingMsgDiv);
                clearTimeout(silenceTimer); 
            };
            topicOptionsContainer.appendChild(option1);

            const option2 = document.createElement('div'); option2.className = 'topic-option';
            option2.textContent = "ë‹¤ë¥¸ ì£¼ì œì— ëŒ€í•´ ë¬¼ì–´ë´ë„ ë ê¹Œìš”?";
            option2.onclick = () => {
                topicBox.style.display = 'none';
                appendMessage("ë‹¤ë¥¸ ì£¼ì œì— ëŒ€í•´ ë¬¼ì–´ë´ë„ ë ê¹Œìš”?", 'user'); 
                handleUserInteraction("ê°€ì¡±ì— ëŒ€í•´ ì´ì•¼ê¸° í•´ ì¤„ ìˆ˜ ìˆì–´?"); 
            };
            topicOptionsContainer.appendChild(option2);
            hasOptions = true;
        }
        
        if (hasOptions) {
            topicBox.style.display = 'block'; 
            setTimeout(() => chatWindow.scrollTop = chatWindow.scrollHeight, 0); 
        } else {
             topicBox.style.display = 'none';
        }
    }

    function startSilenceTimer() {
        clearTimeout(silenceTimer); 
        console.log("[Timer] ì¹¨ë¬µ íƒ€ì´ë¨¸ ì‹œì‘...");
        silenceTimer = setTimeout(async () => {
            if (isRecording) { 
                 console.log("[Timer] ë…¹ìŒ ì¤‘ì´ë¯€ë¡œ ì£¼ì œ ì¶”ì²œ ê±´ë„ˆëœ€."); return; 
            }
            console.log("[Timer] ì¹¨ë¬µ ê°ì§€ë¨. ì£¼ì œ ì¶”ì²œ í‘œì‹œ ì‹œë„.");
            const topics = await loadRecentTopics(); 
            showTopicBox(topics);
        }, SILENCE_TIMEOUT);
    }

    function resetSilenceTimer() {
        clearTimeout(silenceTimer);
        if (topicBox.style.display === 'none' && talkBtn.disabled === false) {
            console.log("[Timer] ì¹¨ë¬µ íƒ€ì´ë¨¸ ë¦¬ì…‹ ë° ì¬ì‹œì‘."); 
            startSilenceTimer();
        } else { 
            console.log("[Timer] ì¹¨ë¬µ íƒ€ì´ë¨¸ ë¦¬ì…‹ (ì£¼ì œ ë°•ìŠ¤ í‘œì‹œ ë˜ëŠ” ë²„íŠ¼ ë¹„í™œì„±í™”ë¡œ ì¸í•´ ì‹œì‘ ì•ˆí•¨)."); 
        }
    }
    
    async function handleUserInteraction(userText, context = {}) {
      if (!userText || userText.trim() === "") { return; }
      console.log("[handleUserInteraction] AI ì‘ë‹µ ì²˜ë¦¬ ì‹œì‘. ì…ë ¥:", userText, "Context:", context);
      disableTalkButton(true, "AI ì‘ë‹µ ëŒ€ê¸° ì¤‘"); 
      topicBox.style.display = 'none';
      loadingIndicatorTalk.style.display = 'block';

      try {
        const gptContext = { 
            userAge: currentUserAge, 
            userDisease: currentUserDisease,
            ...context 
        };
        const gptResponse = await getGptResponse(userText, currentUserId, gptContext); 
        // --- ê°œë°œìë‹˜ ìš”ì²­ ì‚¬í•­ 1: GPT ì‘ë‹µ ê²°ê³¼ ë¡œê¹… ---
        console.log("GPT ì‘ë‹µ ê²°ê³¼:", gptResponse); 
        
        let aiReply = "ì£„ì†¡í•´ìš”, ë‹µë³€ì„ ì´í•´í•˜ëŠ” ë° ì–´ë ¤ì›€ì´ ìˆì—ˆì–´ìš”.";
        let isError = true;

        if (gptResponse) {
            if (gptResponse.rephrasing) {
                aiReply = gptResponse.rephrasing; 
                isError = false;
                if (gptResponse.summary) { 
                    localStorage.setItem('lozee_lastSummary', gptResponse.summary); 
                    lastSummary = gptResponse.summary; 
                }
            } else if (gptResponse.error) { 
                aiReply = gptResponse.error; 
            }
        }
        
        setTimeout(async () => {
            loadingIndicatorTalk.style.display = 'none'; 
            const aiBubbleDiv = appendMessage(aiReply, 'ai', isError); 
            if (aiBubbleDiv) { 
                chatWindow.appendChild(aiBubbleDiv); 
                chatWindow.scrollTop = chatWindow.scrollHeight;
                 // --- ê°œë°œìë‹˜ ìš”ì²­ ì‚¬í•­ 2: TTS í˜¸ì¶œ ë¶€ë¶„ try...catchë¡œ ê°ì‹¸ê¸° ---
                 try {
                    await playTTSFromText(aiReply, currentVoiceId); 
                 } catch (e) {
                    console.error("TTS ì‹¤íŒ¨:", e); // TTS ì‹¤íŒ¨ ì‹œ ì½˜ì†”ì— ì˜¤ë¥˜ ë¡œê¹…
                 }
            }
            disableTalkButton(false, "AI ì‘ë‹µ ì™„ë£Œ");
            resetSilenceTimer(); 
        }, 2000); // 2ì´ˆ ì§€ì—°

      } catch (error) { 
        console.error("[handleUserInteraction] AI ì‘ë‹µ ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸:", error);
        loadingIndicatorTalk.style.display = 'none';
        const fallbackMsg = "ì£„ì†¡í•©ë‹ˆë‹¤, ì‘ë‹µ ì²˜ë¦¬ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ë¬¸ì œê°€ ë°œìƒí–ˆì–´ìš”.";
        const errorBubble = appendMessage(fallbackMsg, 'ai', true);
        if(errorBubble) chatWindow.appendChild(errorBubble);
        try { await playTTSFromText(fallbackMsg, currentVoiceId); } catch (e) { console.error("TTS ì‹¤íŒ¨ (ì˜¤ë¥˜ ì²˜ë¦¬ ì¤‘):", e); }
        disableTalkButton(false, "AI ì‘ë‹µ ì˜¤ë¥˜");
        resetSilenceTimer(); 
      } 
    }

    async function startRecording() {
      if (isRecording) { return; }
      console.log("[startRecording] ë…¹ìŒ ì‹œì‘ ì‹œë„..."); 
      topicBox.style.display = 'none';
      waitingOverlay.style.display = 'none'; 
      try {
        if (mediaStream) { mediaStream.getTracks().forEach(track => track.stop()); }
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        isRecording = true; 
        talkBtn.classList.add('active'); 
        talkBtn.innerHTML = 'â¹ï¸'; 
        disableTalkButton(false, "ë…¹ìŒ ì¤‘"); 
        audioChunks = []; 
        const options = { mimeType: 'audio/webm;codecs=opus' };
        mediaRecorder = new MediaRecorder(mediaStream, options); 
        recordingStartTime = performance.now(); 
        
        mediaRecorder.ondataavailable = event => { 
            if (event.data.size > 0) { audioChunks.push(event.data); }
        };
        mediaRecorder.onstop = async () => {
            console.log("[onstop] ë…¹ìŒ ì¤‘ì§€ë¨, ì²˜ë¦¬ ì‹œì‘...");
            talkBtn.innerHTML = 'ğŸ¤'; 
            talkBtn.classList.remove('active');
            isRecording = false; 

            const recordingEndTime = performance.now();
            const durationInMs = recordingEndTime - (recordingStartTime || recordingEndTime); 
            const durationInSeconds = Math.round(durationInMs / 1000);
            console.log(`[onstop] ë…¹ìŒëœ ì˜¤ë””ì˜¤ ê¸¸ì´ (ì¶”ì •): ${durationInSeconds}ì´ˆ`);

            if (audioChunks.length === 0) { 
                disableTalkButton(false, "ë…¹ìŒ ë°ì´í„° ì—†ìŒ"); 
                resetSilenceTimer(); return; 
            }
            const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType }); 
            audioChunks = [];
            disableTalkButton(true, "STT ì²˜ë¦¬ ì¤‘");
            try {
                const userText = await getSTTFromAudio(audioBlob, durationInSeconds); 
                
                if (userText && userText.trim() !== "") {
                    appendMessage(userText, 'user'); 
                    const isFirstVoiceAfterOnboarding = onboardingComplete && !localStorage.getItem('lozee_first_voice_interaction_done');
                    if (isFirstVoiceAfterOnboarding) {
                        const contextForFirstVoice = {
                            initialUserMessage: userText, 
                            initialUserEmotions: selectedEmotions,
                            isFirstChatAfterOnboarding: true
                        };
                        await handleUserInteraction(userText, contextForFirstVoice);
                        localStorage.setItem('lozee_first_voice_interaction_done', 'true'); 
                        localStorage.removeItem('lozee_selected_emotions'); 
                    } else {
                        await handleUserInteraction(userText); 
                    }
                } else {
                    const noSttMsg = "ì£„ì†¡í•´ìš”, ì˜ ì•Œì•„ë“£ì§€ ëª»í–ˆì–´ìš”."; 
                    const errorBubble = appendMessage(noSttMsg, 'ai', true);
                    if(errorBubble) chatWindow.appendChild(errorBubble);
                    try { await playTTSFromText(noSttMsg, currentVoiceId); } catch(e){ console.error("TTS ì‹¤íŒ¨ (STT ê²°ê³¼ ì—†ìŒ):", e); }
                    disableTalkButton(false, "STT ê²°ê³¼ ì—†ìŒ"); 
                    resetSilenceTimer();
                }
            } catch (sttError) {
                console.error("[onstop] STT ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸:", sttError);
                const sttErrorMsg = "ìŒì„± ì¸ì‹ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì–´ìš”."; 
                const errorBubble = appendMessage(sttErrorMsg, 'ai', true);
                if(errorBubble) chatWindow.appendChild(errorBubble);
                try { await playTTSFromText(sttErrorMsg, currentVoiceId); } catch(e){ console.error("TTS ì‹¤íŒ¨ (STT ì˜¤ë¥˜):", e); }
                disableTalkButton(false, "STT ì˜¤ë¥˜"); 
                resetSilenceTimer();
            }
        };
        mediaRecorder.start(); 
        resetSilenceTimer();
      } catch (error) {
        console.error("[startRecording] ë…¹ìŒ ì‹œì‘ ì¤‘ ì˜ˆì™¸:", error);
        let message = "ë§ˆì´í¬ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ì–´ìš”. ";
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") message += "ë§ˆì´í¬ ì‚¬ìš© ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.";
        else if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") message += "ì—°ê²°ëœ ë§ˆì´í¬ ì¥ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”.";
        else message += `ì˜¤ë¥˜: ${error.message}`;
        const errorBubble = appendMessage(message, 'ai', true); 
        if(errorBubble) chatWindow.appendChild(errorBubble);
        try { await playTTSFromText(message, currentVoiceId); } catch(e){ console.error("TTS ì‹¤íŒ¨ (ë…¹ìŒ ì‹œì‘ ì˜¤ë¥˜):", e); }
        isRecording = false; 
        talkBtn.classList.remove('active'); 
        talkBtn.innerHTML = 'ğŸ¤';
        disableTalkButton(false, "ë…¹ìŒ ì‹œì‘ ì˜¤ë¥˜");
      }
    }

    function stopRecording() {
        console.log("[stopRecording] ë…¹ìŒ ì¤‘ì§€ ìš”ì²­...");
        if (mediaRecorder && mediaRecorder.state === "recording") { 
            mediaRecorder.stop(); 
        } else { 
            isRecording = false; 
            talkBtn.classList.remove('active'); 
            talkBtn.innerHTML = 'ğŸ¤';
            disableTalkButton(false, "ë…¹ìŒ ì¤‘ì§€ë¨ (ìˆ˜ë™)");
        }
        if (mediaStream) { 
            mediaStream.getTracks().forEach(track => track.stop()); 
            mediaStream = null; 
        }
    }

    talkBtn.addEventListener('click', async () => {
      console.log("[talkBtn Click] í˜„ì¬ ë…¹ìŒ ìƒíƒœ:", isRecording, "ì²« ìƒí˜¸ì‘ìš© ì™„ë£Œ:", firstInteractionDone);
      
      waitingOverlay.style.display = 'none'; 

      if (!firstInteractionDone && !onboardingComplete && initialGreetingText) { 
        firstInteractionDone = true; 
        disableTalkButton(true, "ì´ˆê¸° ì¸ì‚¬ë§ TTS ì¤‘");
        loadingIndicatorTalk.style.display = 'block';
        try {
          await playTTSFromText(initialGreetingText, currentVoiceId);
        } catch (error) {
          const errorBubble = appendMessage( error.name === 'NotAllowedError' ? "(ëª©ì†Œë¦¬ë¥¼ ë“¤ìœ¼ë ¤ë©´ í™”ë©´ì„ ë‹¤ì‹œ í•œë²ˆ í´ë¦­í•˜ê±°ë‚˜ ë§ˆì´í¬ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.)" : "(ì´ˆê¸° ì•ˆë‚´ ìŒì„± ì¬ìƒ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.)", "ai", true);
          if(errorBubble) chatWindow.appendChild(errorBubble);
          console.error("TTS ì‹¤íŒ¨ (ì´ˆê¸° ì¸ì‚¬):", error);
        } finally {
          loadingIndicatorTalk.style.display = 'none';
          disableTalkButton(false, "ì´ˆê¸° ì¸ì‚¬ë§ TTS ì™„ë£Œ/ì‹¤íŒ¨");
          resetSilenceTimer();
        }
        return; 
      }

      if (!isRecording) {
        startRecording();
      } else {
        stopRecording(); 
      }
    });
    
    waitingOverlay.addEventListener('click', () => {
        waitingOverlay.style.display = 'none';
        resetSilenceTimer(); 
    });

    async function initializeChat() {
      disableTalkButton(true, "ì´ˆê¸°í™” ì¤‘");
      console.log("ì±„íŒ… ì´ˆê¸°í™” ì‹œì‘...");

      if (!currentUserId || !currentVoiceId) {
          const errorMsg = "ì‚¬ìš©ì ì •ë³´(ID ë˜ëŠ” ëª©ì†Œë¦¬)ê°€ ì—†ì–´ ì±„íŒ…ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„¤ì • ë˜ëŠ” ì‹œì‘ í˜ì´ì§€ë¡œ ì´ë™í•´ì£¼ì„¸ìš”.";
          console.error("[initializeChat]", errorMsg); 
          const errorBubble = appendMessage(errorMsg, 'ai', true);
          if(errorBubble) chatWindow.appendChild(errorBubble);
          loadingIndicatorTalk.style.display = 'none'; 
          disableTalkButton(true, "ì‚¬ìš©ì ì •ë³´ ì—†ìŒ");
          return;
      }

      try {
        if (onboardingComplete && userTypedIntro) { 
            console.log("ì˜¨ë³´ë”© ì™„ë£Œ. ì‚¬ìš©ìê°€ intro.htmlì—ì„œ ì…ë ¥í•œ ì²«ë§ˆë””ì™€ ê°ì •ìœ¼ë¡œ ëŒ€í™” ì‹œì‘.");
            appendMessage(userTypedIntro, 'user'); 

            const contextForFirstInteraction = { 
                initialUserMessage: userTypedIntro, 
                initialUserEmotions: selectedEmotions, 
                isFirstChatAfterOnboarding: true 
            };
            await handleUserInteraction(userTypedIntro, contextForFirstInteraction);
            
            localStorage.removeItem('lozee_onboarding_complete'); 
            localStorage.removeItem('lozee_user_typed_intro'); 
            firstInteractionDone = true; 

        } else if (onboardingComplete && !userTypedIntro) { 
            console.log("ì˜¨ë³´ë”© ì™„ë£Œ. ì‚¬ìš©ìì˜ ì²« ìŒì„± ì…ë ¥ì„ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.");
            initialGreetingText = `ë§Œë‚˜ì„œ ë°˜ê°€ì›Œìš”, ${currentUserName}ë‹˜! ì´ì œ ëŒ€í™”ë¥¼ ì‹œì‘í•  ì¤€ë¹„ê°€ ë˜ì—ˆì–´ìš”. ì•„ë˜ ë§ˆì´í¬ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì§€ê¸ˆ ì–´ë–¤ì§€ ë§ì”€í•´ì£¼ì„¸ìš”.`;
            const aiGreetingBubble = appendMessage(initialGreetingText, 'ai');
            if(aiGreetingBubble) chatWindow.appendChild(aiGreetingBubble); 
            
            loadingIndicatorTalk.style.display = 'block';
            try {
                await playTTSFromText(initialGreetingText, currentVoiceId);
            } catch(ttsError){
                console.error("ì˜¨ë³´ë”© í›„ ì²« ì¸ì‚¬ TTS ì˜¤ë¥˜:", ttsError);
            } finally {
                loadingIndicatorTalk.style.display = 'none';
            }
            disableTalkButton(false, "ì˜¨ë³´ë”© í›„ ì²« ìŒì„± ì…ë ¥ ëŒ€ê¸°");
            firstInteractionDone = true; 

        } else { 
            const urlParams = new URLSearchParams(window.location.search);
            const topicFromUrl = urlParams.get('topic');
            if (topicFromUrl) { 
              const userMsg = `"${topicFromUrl}"ì— ëŒ€í•´ ì´ì•¼ê¸°í•˜ê³  ì‹¶ì–´ìš”.`; 
              appendMessage(userMsg, 'user');
              await handleUserInteraction(`"${topicFromUrl}" ê´€ë ¨í•´ì„œ ì´ì•¼ê¸° ì‹œì‘í•´ì¤˜.`);
              firstInteractionDone = true; 
            } else { 
              initialGreetingText = await getInitialGreeting(currentUserName, hasVisited, lastSummary, currentUserAge, currentUserDisease);
              const aiGreetingBubble = appendMessage(initialGreetingText, 'ai');
              if(aiGreetingBubble) chatWindow.appendChild(aiGreetingBubble);
              disableTalkButton(false, "ì´ˆê¸°í™” ì™„ë£Œ, ì²« í´ë¦­ ëŒ€ê¸°"); 
            }
        }
        if (!hasVisited) { 
            localStorage.setItem('lozee_hasVisited', 'true'); 
            hasVisited = true; 
        }
      } catch (error) {
          console.error("[initializeChat] ì´ˆê¸°í™” ì¤‘ ì˜ˆì™¸:", error);
          const errorBubble = appendMessage("ì±„íŒ… ì‹œì‘ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆì–´ìš”. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨ í•´ë³´ì„¸ìš”.", 'ai', true);
          if(errorBubble) chatWindow.appendChild(errorBubble);
          disableTalkButton(true, "ì´ˆê¸°í™” ì˜¤ë¥˜");
      } finally {
        console.log("ì±„íŒ… ì´ˆê¸°í™” ì™„ë£Œ.");
        resetSilenceTimer(); 
      }
    }
    initializeChat();
  </script>
</body>
</html>
