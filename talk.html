<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>LOZEE와 대화</title> 
  <link rel="stylesheet" href="style.css"> <link href="https://fonts.googleapis.com/css2?family=KoPub+World+Dotum:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { 
      display: flex; 
      flex-direction: column; 
      min-height: 100vh; 
      background-color: #ffffff; 
      color: #333; 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      margin: 0;
      overflow: hidden; 
    }
    #main-header {
      background-color: #0095FF; color: white; padding: 0.8rem 1rem;
      text-align: center; font-size: 1.1em; 
      font-weight: bold; flex-shrink: 0; 
    }
    #chat-container { 
      flex: 1; display: flex; flex-direction: column; 
      overflow-y: hidden; 
      width: 100%; max-width: 700px; 
      margin: 0 auto; box-sizing: border-box; 
      position: relative; 
    }
    #chat-window { 
      flex: 1; 
      overflow-y: auto; 
      padding: 15px; 
      padding-bottom: 70px; 
      display: flex; 
      flex-direction: column; gap: 10px; 
    }
    .bubble { 
      max-width: 85%; padding: 10px 15px; border-radius: 18px; 
      line-height: 1.5; font-size: 1em; 
      white-space: pre-wrap; 
      box-shadow: 0 1px 2px rgba(0,0,0,0.08); 
    }
    .user { 
      background-color: #FFFDE7; 
      color: #424242; align-self: flex-end; 
      margin-left: auto; border-bottom-right-radius: 5px; 
    }
    .ai { 
      background-color: #E3F2FD; 
      color: #1E88E5; align-self: flex-start; 
      margin-right: auto; border-bottom-left-radius: 5px; 
    }
    .bubble.ai.error { background-color: #FFEBEE; color: #C62828; border: 1px solid #EF9A9A; }
    #loading-indicator-talk { 
      text-align: center; padding: 8px; display: none; 
      color: #757575; font-style: italic; font-size: 0.9em;
    }
    
    #input-controls-container { 
      padding: 10px; 
      background-color: #f5f5f5; 
      flex-shrink: 0; 
      border-top: 1px solid #e0e0e0; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      gap: 10px; 
      width: 100%;
      box-sizing: border-box;
      position: fixed; 
      bottom: 0;
      left: 0;
      z-index: 100;
    }

    #talk-btn, #toggle-input-btn { 
      width: 48px; height: 48px; 
      border-radius: 50%; 
      border: none; 
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); 
      color: white; 
      cursor: pointer; display: inline-flex; 
      justify-content: center; align-items: center; 
      transition: transform 0.1s ease, background-color 0.2s; 
      flex-shrink: 0; 
      font-weight: bold; 
      font-size: 20px; 
    }
    #talk-btn { 
      background-color: #0095FF; 
      font-size: 22px; 
    }
    #talk-btn.active { background-color: #ff4500; transform: scale(1.1); }
    #talk-btn:disabled { background-color: #bdbdbd; cursor: not-allowed; transform: scale(1.0); }

    #toggle-input-btn { 
      background-color: #FFEB3B; 
      color: #333; 
    }
    #toggle-input-btn:hover { opacity: 0.85; }
    #toggle-input-btn svg { 
        width: 24px; 
        height: 24px;
        fill: white; 
    }
     body.keyboard-mode #toggle-input-btn { 
        background-color: #0095FF; 
        color: white; 
    }

    #text-input-area {
      display: none; 
      flex-grow: 1; 
      display: flex; 
      align-items: flex-end; 
      gap: 8px; 
    }
    #user-text-input { 
      flex-grow: 1; 
      min-height: 22px; 
      max-height: 100px; 
      border-radius: 20px; 
      padding: 10px 15px; 
      border: 1px solid #bdbdbd; 
      font-size: 1em; 
      font-family: 'KoPubWorld Dotum', sans-serif; 
      resize: none; 
      line-height: 1.4;
      overflow-y: auto; 
      background-color: white;
    }
    #send-text-btn { 
      background-color: #0095FF; 
      color: white; border: none; cursor: pointer;
      border-radius: 50%; 
      width: 40px; 
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0; 
      flex-shrink: 0; 
      transition: background-color 0.2s;
    }
    #send-text-btn svg { 
        width: 20px;
        height: 20px;
        fill: white;
    }
    #send-text-btn:hover { background-color: #0077cc; }
    #send-text-btn:disabled { background-color: #bdbdbd; }

    @media (max-width: 768px) {
      #chat-window {
        padding-bottom: 60px; 
      }
      body.keyboard-mode #chat-window {
         /* JS에서 adjustChatWindowPadding 함수로 동적 조절 */
      }
      body.keyboard-mode #input-controls-container {
        /* 이미 fixed이므로 추가 스타일 불필요할 수 있음 */
      }
      body.keyboard-mode #talk-btn { 
        display: none; 
      }
      body.keyboard-mode #text-input-area { 
        display: flex; 
      }
    }

    #topic-selection { /* (기존 스타일과 동일) */ }
    #waiting-overlay { /* (기존 스타일과 동일) */ }
  </style>
</head>
<body>
  <header id="main-header">LOZEE와 대화하기</header>

  <div id="chat-container">
    <div id="chat-window"></div>
    <div id="topic-selection" style="display: none;">
      <h3>이야기를 이어가고 싶은 주제를 골라볼래?</h3>
      <div id="topic-options"></div>
    </div>
  </div>

  <div id="loading-indicator-talk">AI 응답 준비 중...</div>
  
  <div id="input-controls-container">
    <button id="toggle-input-btn" aria-label="입력 방식 전환">
      <span id="toggle-icon-text-T">T</span> 
      <svg viewBox="0 0 24 24" id="mic-icon-for-toggle-btn" style="display:none;"> 
        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"></path>
      </svg>
    </button>
    <div id="text-input-area"> 
      <textarea id="user-text-input" placeholder="메시지를 입력하세요..." rows="1"></textarea>
      <button id="send-text-btn" aria-label="전송">
        <svg viewBox="0 0 24 24">
          <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path>
        </svg>
      </button>
    </div>
    <button id="talk-btn" aria-label="말하기">🎤</button> 
  </div>

  <div id="waiting-overlay" style="display: none;">
    <p><span id="waitingUserName"></span>님, 잠시 기다리는 중...<br><small>(화면을 클릭하면 다시 시작할 수 있어요)</small></p>
  </div>

  <script type="module">
    import { playTTSFromText } from './js/tts.js';
    import { getSTTFromAudio } from './js/stt.js';
    import { getGptResponse, getInitialGreeting } from './js/gpt-dialog.js';
    // [3] 추임새 헬퍼 import
    import { getIsPoliteByAge, speakInterjection } from './js/interjection-helper.js';

    console.log("talk.html 스크립트 시작 (v3.19 - 마이크 활성화, 추임새 기능 추가)");

    // ... (기존 DOM 요소 및 변수 선언은 동일하게 유지)
    const talkBtn = document.getElementById('talk-btn');
    const chatWindow = document.getElementById('chat-window');
    const toggleInputBtn = document.getElementById('toggle-input-btn');
    const textInputArea = document.getElementById('text-input-area');
    const userTextInput = document.getElementById('user-text-input');
    const sendTextBtn = document.getElementById('send-text-btn');
    const inputControlsContainer = document.getElementById('input-controls-container');
    const toggleIconTextT = document.getElementById('toggle-icon-text-T'); 
    const micIconForToggleBtn = document.getElementById('mic-icon-for-toggle-btn'); 
    const loadingIndicatorTalk = document.getElementById('loading-indicator-talk');
    const topicBox = document.getElementById('topic-selection'); 
    const waitingOverlay = document.getElementById('waiting-overlay'); 
    const waitingUserName = document.getElementById('waitingUserName'); 

    let currentInputMode = 'microphone'; 
    const currentUserName = localStorage.getItem('lozee_username') || "친구";
    const currentUserId = localStorage.getItem('lozee_username'); 
    document.title = `${currentUserName}님과의 LOZEE 대화`;
    const ADMIN_SECRET_PHRASE = "맹고양이"; 
    const ADMIN_EMAIL = "maengnanyoung@gmail.com";
    const MAX_RECORDING_DURATION = 45000; 
    let isRecording = false;
    let mediaRecorder;
    let audioChunks = [];
    let mediaStream = null;
    let silenceTimer; 
    const SILENCE_TIMEOUT = 20000; 
    let firstInteractionDone = false; 
    let initialGreetingText = "";    
    let recordingStartTime; 
    let maxDurationTimeoutId; 
    let userConsecutiveTurns = 0;
    const MAX_CONSECUTIVE_TURNS = 5;
    let lastUserUtterance = ""; 
    let consecutiveTurnTimeoutId; 
    const CONSECUTIVE_TURN_SILENCE_TIMEOUT = 7000; 
    const currentVoiceId = localStorage.getItem('lozee_voice');
    const currentUserAge = localStorage.getItem('lozee_userage');
    const currentUserDisease = localStorage.getItem('lozee_userdiagnosis');
    let hasVisited = localStorage.getItem('lozee_hasVisited') === 'true';
    let lastSummary = localStorage.getItem('lozee_lastSummary') || '';
    const onboardingComplete = localStorage.getItem('lozee_onboarding_complete') === 'true';
    const userTypedIntro = localStorage.getItem('lozee_user_typed_intro'); 
    const selectedEmotionsString = localStorage.getItem('lozee_selected_emotions');
    let selectedEmotions = [];
    if (selectedEmotionsString) {
        try { selectedEmotions = JSON.parse(selectedEmotionsString); } 
        catch (e) { console.error("선택된 감정 localStorage 파싱 오류:", e); selectedEmotions = []; }
    }

    // --- 함수 정의들 (adjustChatWindowPadding, appendMessage, disableAllInputs, 타이머 함수들, handleUserInteraction, stopRecordingIfMaxDuration, startRecording, stopRecording) ---
    // 이전 버전과 거의 동일하며, [1] 마이크 활성화 및 [3] 추임새 관련 로직이 startRecording, mediaRecorder.onstop, handleUserInteraction에 추가/수정됩니다.
    // (가독성을 위해 전체 함수 코드를 반복하지 않고, 주요 변경점 위주로 설명합니다. 실제 파일에는 모든 함수가 포함되어야 합니다.)

    function adjustChatWindowPadding() { /* 이전과 동일 */ }
    function appendMessage(text, role = 'ai', isError = false) { /* 이전과 동일 */ }
    
    function disableAllInputs(disable = true, reason = "") {
      talkBtn.disabled = disable;
      sendTextBtn.disabled = disable;
      userTextInput.disabled = disable;
      // 녹음 중이 아닐 때만 토글 버튼 활성화/비활성화 (녹음 중에는 항상 비활성화)
      if (!isRecording) {
        toggleInputBtn.disabled = disable;
      } else {
        toggleInputBtn.disabled = true; // 녹음 중에는 항상 비활성화
      }
      console.log(`[disableAllInputs] ${disable ? '비활성화' : '활성화'}${reason ? ` (${reason})` : ''}`);
    }

    function resetSilenceTimer() { /* 이전과 동일 */ }
    function startSilenceTimer() { /* 이전과 동일 */ }
    function startConsecutiveTurnSilenceTimer() { /* 이전과 동일 */ }
    function resetConsecutiveTurnSilenceTimer() { /* 이전과 동일 */ }

    async function handleUserInteraction(userText, context = {}) { 
      if (!userText || userText.trim() === "") { 
        console.warn("[handleUserInteraction] userText가 비어있어 처리 중단.");
        disableAllInputs(false, "사용자 입력 없음");
        return; 
      }
      disableAllInputs(true, "AI 응답 대기 중"); 
      loadingIndicatorTalk.style.display = 'block';
      clearTimeout(silenceTimer); 
      clearTimeout(consecutiveTurnTimeoutId);
      console.log("[handleUserInteraction] GPT 요청 시작. UserText:", userText.substring(0,50), "Context:", context);

      // [3] AI 응답 전 추임새 (선택적, 사용자가 말을 마치고 AI가 생각하는 것처럼)
      // 연속 발화가 끝나고 AI가 응답할 때만 추임새를 넣습니다.
      if (userConsecutiveTurns === 0) { // 연속 발화가 모두 끝났음을 의미
        try {
            const isPolite = getIsPoliteByAge();
            speakInterjection(isPolite);
            console.log("[Interjection] AI 응답 전 추임새 재생됨.");
            // 추임새 재생 시간만큼 약간의 딜레이를 줄 수 있으나, TTS와 겹칠 수 있으므로 일단 생략
        } catch (e) {
            console.error("추임새 재생 중 오류:", e);
        }
      }

      try {
        const gptContext = { userAge: currentUserAge, userDisease: currentUserDisease, ...context };
        const gptResponse = await getGptResponse(userText, currentUserId, gptContext); 
        console.log("GPT 응답 결과 (handleUserInteraction):", gptResponse); 
        
        let aiReply = "죄송해요, 답변을 이해하는 데 어려움이 있었어요.";
        let isError = true;

        if (gptResponse) {
            if (gptResponse.rephrasing) { aiReply = gptResponse.rephrasing; isError = false;
                if (gptResponse.summary) { localStorage.setItem('lozee_lastSummary', gptResponse.summary); lastSummary = gptResponse.summary; }
            } else if (gptResponse.error) { aiReply = gptResponse.error; }
        }
        
        setTimeout(async () => { 
            loadingIndicatorTalk.style.display = 'none'; 
            console.log("[handleUserInteraction] AI 응답 UI에 표시 및 TTS 시작. AI Reply:", aiReply.substring(0,50));
            appendMessage(aiReply, 'ai', isError); 
            try { 
                if (!isError && aiReply) { 
                    await playTTSFromText(aiReply, currentVoiceId); 
                }
            } 
            catch (e) { console.error("TTS 실패 (handleUserInteraction):", e.message ? e.message : e); }
            disableAllInputs(false, "AI 응답 완료");
            resetSilenceTimer(); 
        }, isError ? 300 : 1000); // 추임새 시간을 고려하여 이 지연을 조절할 수 있음

      } catch (error) { /* 이전과 동일 */ } 
    }

    function stopRecordingIfMaxDuration() { /* 이전과 동일 */ }

    async function startRecording() {
      // [1] 마이크 활성화 로직 확인 및 강화
      if (isRecording) { 
        console.warn("[startRecording] 이미 녹음 중입니다.");
        return; 
      }
      if (currentInputMode !== 'microphone') {
        console.warn("[startRecording] 현재 마이크 입력 모드가 아닙니다.");
        return;
      }

      disableAllInputs(true, "녹음 준비 중"); // 모든 입력 비활성화 (토글 버튼 포함)
      
      console.log("[startRecording] 녹음 시작 시도..."); 
      topicBox.style.display = 'none';
      waitingOverlay.style.display = 'none'; 
      clearTimeout(silenceTimer); 
      clearTimeout(consecutiveTurnTimeoutId); 

      try {
        if (mediaStream) { 
            mediaStream.getTracks().forEach(track => track.stop()); 
            console.log("[startRecording] 기존 미디어 스트림 중지됨.");
        }
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        console.log("[startRecording] 마이크 접근 성공. 미디어 스트림 가져옴.");
        isRecording = true; 
        talkBtn.classList.add('active'); 
        talkBtn.innerHTML = '⏹️'; 
        disableAllInputs(false, "녹음 중"); // 모든 입력 활성화
        talkBtn.disabled = false; // 중지 버튼은 항상 활성화
        toggleInputBtn.disabled = true; // 녹음 중에는 모드 변경 불가

        audioChunks = []; 
        const options = { mimeType: 'audio/webm;codecs=opus' };
        mediaRecorder = new MediaRecorder(mediaStream, options); 
        console.log("[startRecording] MediaRecorder 생성됨. 옵션:", options);
        recordingStartTime = performance.now(); 
        
        maxDurationTimeoutId = setTimeout(stopRecordingIfMaxDuration, MAX_RECORDING_DURATION);
        
        mediaRecorder.ondataavailable = event => { 
            if (event.data.size > 0) { 
                audioChunks.push(event.data); 
                // console.log("[ondataavailable] 오디오 청크 수신:", event.data.size);
            }
        };

        mediaRecorder.onstart = () => { // [1] 녹음 시작 시점 명확히 로깅
            console.log("[MediaRecorder] 녹음이 실제로 시작되었습니다.");
        };

        mediaRecorder.onstop = async () => { /* 이전과 동일 (관리자 명령 확인 로직 포함) */ };
        
        mediaRecorder.start(1000); // 1초 간격으로 ondataavailable 호출 (선택 사항)
        console.log("[startRecording] mediaRecorder.start() 호출됨.");

      } catch (error) { 
          console.error("[startRecording] 녹음 시작 중 예외:", error);
          let message = "마이크를 시작할 수 없어요. ";
          if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") message += "마이크 사용 권한을 허용해주세요.";
          else if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") message += "연결된 마이크 장치를 찾을 수 없어요.";
          else message += `오류: ${error.message || error}`; // 오류 객체 전체 또는 메시지 출력
          appendMessage(message, 'ai', true); 
          isRecording = false; 
          talkBtn.classList.remove('active'); 
          talkBtn.innerHTML = '🎤';
          disableAllInputs(false, "녹음 시작 오류");
      }
    }

    function stopRecording() { /* 이전과 동일 */ }
    toggleInputBtn.addEventListener('click', () => { /* 이전과 동일 */ });
    sendTextBtn.addEventListener('click', async () => { /* 이전과 동일 (관리자 명령 확인 로직 포함) */ });
    userTextInput.addEventListener('keypress', (event) => { /* 이전과 동일 */ });
    userTextInput.addEventListener('input', () => { /* 이전과 동일 */ });
    talkBtn.addEventListener('click', async () => { /* 이전과 동일 (currentInputMode !== 'microphone' return 추가) */ });
    window.addEventListener('resize', adjustChatWindowPadding); 
    async function initializeChat() { /* 이전과 동일 (disableAllInputs(false) 호출 시점 조정) */ }

    initializeChat();
  </script>
</body>
</html>
