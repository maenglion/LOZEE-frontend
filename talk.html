<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LOZEE와 대화하기</title>
    <link href="https://fonts.googleapis.com/css2?family=KoPub+World+Dotum:wght@400;700&display=swap" rel="stylesheet"/> 
    <link rel="stylesheet" href="gnb.css"> 
<style>
  :root {
      --primary-color: #6e8efb;
      --secondary-color: #5a7edf;
      --background-color: #ffffff;
      --text-color: #333333;
      
      --user-bubble-bg: var(--primary-color);
      --user-bubble-text: #ffffff;
      --assistant-bubble-bg: #F5E7A1; /* 로지 말풍선 배경색 */
      --assistant-bubble-text: #333333;

      --input-area-bg: #f8f9fa;
      --chat-input-bg: #ffffff;
      --chat-input-text-color: #333333;
      --chat-input-border-color: #ced4da;
      --chat-input-placeholder-color: #777777;

      --button-bg: var(--primary-color);
      --button-text-color: #ffffff;
      --button-hover-bg: var(--secondary-color);

      --volume-meter-container-bg: #e9ecef;
      --volume-meter-level-bg: var(--primary-color);
      --meter-height: 6px;
      --meter-top-margin: 8px;

      --analysis-notification-bg: #fff3cd;
      --analysis-notification-text: #856404;

      --gnb-height: 56px; 
      --chat-input-area-height: 70px;
    }

    body {
      margin: 0;
      padding-top: var(--gnb-height); 
      font-family: 'KoPub World Dotum', sans-serif;
      background: var(--background-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      height: 100vh;
      box-sizing: border-box;
      overflow: hidden;
    }

    #meter-container {
      position: fixed;
      top: calc(var(--gnb-height) + var(--meter-top-margin));
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      max-width: 300px;
      height: var(--meter-height);
      background: var(--volume-meter-container-bg);
      border-radius: 3px;
      overflow: hidden;
      z-index: 998;
    }
    #volume-level {
      width: 0%;
      height: 100%;
      background: var(--volume-meter-level-bg);
      border-radius: 3px;
      transition: width 0.05s linear, background-color 0.05s linear;
    }
    
    #chat-window {
      flex: 1;
      padding: 16px;
      padding-top: calc(var(--meter-top-margin) + var(--meter-height) + 10px);
      padding-bottom: calc(var(--chat-input-area-height) + 10px);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-sizing: border-box;
    }
    
    #chat-window::-webkit-scrollbar { width: 8px; }
    #chat-window::-webkit-scrollbar-track { background: var(--background-color); }
    #chat-window::-webkit-scrollbar-thumb { background: #cccccc; border-radius: 4px; }
    #chat-window::-webkit-scrollbar-thumb:hover { background: #aaaaaa; }

    .bubble {
      max-width: 75%;
      padding: 10px 15px;
      border-radius: 18px;
      line-height: 1.6;
      word-break: keep-all;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .bubble.user {
      background: var(--user-bubble-bg);
      color: var(--user-bubble-text);
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .bubble.assistant { 
      background: var(--assistant-bubble-bg);
      color: var(--assistant-bubble-text);
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .bubble.assistant_feedback { 
      background: #e9ecef; 
      color: #495057;
      align-self: center; 
      font-size: 0.9em;
      border-radius: 8px;
    }
    .bubble.thinking { 
      background: var(--assistant-bubble-bg);
      color: var(--assistant-bubble-text);
      align-self: flex-start;
      border-bottom-left-radius: 4px;
      font-style: italic;
      opacity: 0.8;
    }

    .manual-save-btn { /* 수동 저장 버튼 스타일 (선택 사항) */
      background-color: #4CAF50; /* 초록색 계열 */
      color: white;
      border-color: #388E3C;
    }
  
  .journal-save-notification { /* 저널 저장 알림 스타일 */
      align-self: center;
      background: #e8f5e9; /* 연한 초록색 */
      color: #2e7d32;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 0.9em;
      margin: 5px 0;
      border: 1px solid #c8e6c9;
  }

    .analysis-notification {
      align-self: center;
      background: var(--analysis-notification-bg);
      color: var(--analysis-notification-text);
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 0.9em;
      margin: 5px 0;
    }

    #topic-area { 
      display: none !important; 
    }

    #input-area {
      padding: 0 30px; 
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: var(--chat-input-area-height);
      display: none; 
      align-items: center;
      gap: 8px;
      background: var(--input-area-bg);
      border-top: 1px solid #e0e0e0;
      box-sizing: border-box;
    }
    #input-area button, #input-area input {
      font-size: 1em;
      height: 44px;
      box-sizing: border-box;
    }

    #chat-input {
      flex: 1;
      min-width: 50px; 
      padding: 10px 16px;
      border: 1px solid var(--chat-input-border-color);
      border-radius: 22px;
      outline: none;
      background-color: var(--chat-input-bg);
      color: var(--chat-input-text-color);
    }
    #chat-input::placeholder {
      color: var(--chat-input-placeholder-color);
    }

    #mic-button, #send-btn {
      width: 44px;
      min-width: 44px; 
      height: 44px;
      border: none;
      border-radius: 50%;
      background: var(--button-bg);
      color: var(--button-text-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3em;
      transition: background-color 0.2s ease;
      flex-shrink: 0; 
    }
    #mic-button:hover, #send-btn:hover {
      background: var(--button-hover-bg);
    }
    #mic-button.recording {
      background: #e74c3c;
    }
    #send-btn.loading {
        background:#cccccc;
        cursor:default;
    }
    
    @media (max-width: 600px) {
      #input-area { padding: 0 20px; gap: 5px; } 
      .bubble { padding: 9px 13px; max-width: 85%; }
      #chat-input { padding: 9px 14px; }
      #mic-button, #send-btn { width: 40px; height: 40px; font-size: 1.2em;}
      #input-area { height: 65px; }
      #chat-window { padding-bottom: calc(65px + 10px); }
    }
     @media (max-width: 360px) { 
        #input-area { padding: 0 10px; gap: 5px; }
        #mic-button, #send-btn { width: 38px; height: 38px; font-size: 1.1em; }
        #chat-input { height: 38px; }
    }

    .chat-options-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 10px 0;
      align-items: flex-start;
      max-width: 80%;
      align-self: flex-start;
    }
    .chat-option-btn {
      background-color: #f1f1f1;
      color: #333333;
      border: 1px solid #dcdcdc;;
      border-radius: 12px;
      padding: 10px 15px;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 0.95em;
      transition: background-color 0.2s, transform 0.1s;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .chat-option-btn:hover {
      background-color: #e9e9e9;
      transform: translateY(-1px);
    }
    .chat-option-btn.selected {
      background-color: #E4D2FD; 
      color: #333;
      border-color: #c3b2e0; 
      font-weight: bold;
    }
    .chat-option-btn.continue-topic-btn { 
        background-color: #FFDAB9; 
        border-color: #FFA07A;
    }
    .chat-option-btn:disabled {
      background-color: #f8f8f8;
      color: #aaaaaa;
      cursor: not-allowed;
      opacity: 0.7;
    }
    .chat-option-btn.manual-save-btn {
     background-color: #ff7f7f;
     color: #ffffff;
     border-color: #4f69ff;
     }
</style>
</head>
<body>
    <nav id="gnb">
        <div id="gnb-title">LOZEE</div>
        <button id="menu-toggle">☰</button>
        <div id="dropdown-menu">
          <a href="mypage.html">🎨 내 정보 보기</a> 
          <a href="index.html">✨ 새로운 이야기 시작!</a> 
          <a href="analysis.html">📊 우리 이야기 분석</a> 
          <a href="journal-list.html">📖 이야기 모음집</a> 
          <a href="https://www.notion.so/maenglionworld/lOZEE-1ebbcdc037cd80fa9c0ddef234121e84?pvs=4" target="_blank">❓ 로지 사용 설명서</a> 
        </div>
    </nav>

    <div id="meter-container"><div id="volume-level"></div></div>
    <div id="chat-window"></div>
    <div id="input-area">
        <button id="mic-button">🎤</button>
        <input id="chat-input" type="text" placeholder="메시지를 입력하세요..." autocomplete="off" />
        <button id="send-btn">➤</button>
    </div>

    <script type="module">
        import './js/firebase-config.js';
        import { db } from './js/firebase-config.js';
        import { doc, getDoc, setDoc } from 'https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore.js';
        import { getInitialGreeting, getGptResponse, getKoreanVocativeParticle } from './js/gpt-dialog.js';
        import { playTTSFromText, stopCurrentTTS } from './js/tts.js';
        import LOZEE_ANALYSIS from './js/lozee-analysis.js';
        // ⭐ saveManualJournalEntry import 추가
        import { saveJournalEntry, saveManualJournalEntry, updateTopicStats, logSessionStart, logSessionEnd } from './js/firebase-utils.js'; 
        import { counselingTopicsByAge } from './js/counseling_topics.js';

        // --- 상태 변수 ---
        let skipTTS = false;
        let hasGreeted = false;
        let isProcessing = false;
        let chatHistory = [];
        let selectedMain = null; 
        let isPlayingTTS = false; 
        let conversationStartTime = null;
       
        let analysisNotificationShown = false; // 상세 분석 알림 여부
        let journalSaveNotificationShown = false; // 저널 저장 알림 여부 (800자 기준)
        
        let sessionTimeoutId = null;
        const SESSION_TIMEOUT_DURATION = 5 * 60 * 1000; // 5분
        let lastAiAnalysisData = null; 
        
        let userTurnCountInSession = 0; 
        let userCharCountInSession = 0; 
        let previousTotalUserCharCountOverall = 0;

        let assistantMessageCount = 0, gptVerbosityPreference = 'default';
        let lastVerbosityPromptTime = 0, verbosityPromptCount = 0; 
        const PREFERENCE_PROMPT_INTERVAL = 10 * 60 * 1000;
        let currentFirestoreSessionId = null; 

        // ─── 추가된 상태 변수: 수동 저장 대기/확정 플래그 ─────────────────────
        let awaitManualSave = false;         // Assistant가 “방법을 알려줄까?” 라고 물었을 때 true로 설정
        let manualSaveConfirmed = false;     // 사용자가 “방법을 알려줘.” 선택 시 true로 설정
        let isMicProcessing = false; // 마이크 버튼 중복 클릭 방지 플래그



        // --- UI 요소 ---
        const chatWindow = document.getElementById('chat-window');
        const topicArea = document.getElementById('topic-area'); 
        const inputArea = document.getElementById('input-area');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const micButton = document.getElementById('mic-button');
        // GNB 메뉴 토글은 gnb.js에서 처리하므로, talk.html 내 직접적인 GNB JS 코드 삭제
        const meterLevel = document.getElementById('volume-level');

        // --- 사용자 정보 ---
        const userName = localStorage.getItem('lozee_username') || '친구';
        const userAge = parseInt(localStorage.getItem('lozee_userage') || '0', 10); 
        const currentUserEmail = localStorage.getItem('cbtUserEmail');
        const userType = localStorage.getItem('lozee_userType') || '';
        const voc = getKoreanVocativeParticle(userName);

        // --- Firestore에서 이전 누적 글자 수 가져오는 함수 ---
        async function fetchPreviousUserCharCount() {
            if (!currentUserEmail) return 0;
            try {
                const userRef = doc(db, 'users', currentUserEmail);
                const userSnap = await getDoc(userRef);
                if (userSnap.exists() && userSnap.data().totalUserCharCount) {
                    return parseInt(userSnap.data().totalUserCharCount, 10) || 0;
                }
            } catch (error) {
                console.error("Firestore에서 이전 누적 글자 수 로드 오류:", error);
            }
            return 0;
        }

        // --- 초기화 로직 ---
document.addEventListener('DOMContentLoaded', async () => {
            console.log('talk.html: DOMContentLoaded 이벤트 발생');
            if (!currentUserEmail) {
                alert("사용자 정보가 없습니다. 다시 로그인해주세요.");
                window.location.href = 'index.html'; return;
            }
            conversationStartTime = Date.now(); 
            previousTotalUserCharCountOverall = await fetchPreviousUserCharCount();
            resetSessionTimeout(); 

            let startedWithInitTopic = false; // 이어하기로 시작했는지 여부 플래그
            const initTopicDataString = localStorage.getItem('lozee_talk_init_topic');
            if (initTopicDataString) {
                try {
                    const initTopic = JSON.parse(initTopicDataString);
                    localStorage.removeItem('lozee_talk_init_topic'); 
                    if (initTopic.details) { 
                        selectedMain = initTopic.details; 
                        const initialMessageFromLozee = initTopic.prompt || `지난번 '${selectedMain}' 이야기에 이어서 더 나눠볼까? 어떤 점이 궁금하거나 더 이야기하고 싶어?`;
                        appendMessage(initialMessageFromLozee, 'assistant');
                        console.log(`talk.html: "${selectedMain}" 주제 이어하기 시작.`);
                        startChat(initialMessageFromLozee, 'topic_selection_init'); 
                        hasGreeted = true; // 이어하기도 일종의 인사로 간주
                        startedWithInitTopic = true; 
                    }
                } catch (e) { 
                    console.error("이어하기 주제(lozee_talk_init_topic) 파싱 오류:", e); 
                    localStorage.removeItem('lozee_talk_init_topic');
                }
            }

            // ⭐ 이어하기로 시작하지 않은 경우에만 일반적인 첫인사 및 주제 선택 표시 ⭐
            if (!startedWithInitTopic) {
                const greeting = getInitialGreeting(userName + voc, hasGreeted);
                appendMessage(greeting, 'assistant');
                hasGreeted = true;
                showMainTopics(); // 주제 선택 버튼 표시
            }
        });


        // --- 메시지 관련 함수 ---
        function appendMessage(text, role) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble ' + role; 
            bubble.textContent = text;
            if(chatWindow) { 
            chatWindow.appendChild(bubble); 
            chatWindow.scrollTop = chatWindow.scrollHeight; } 
            else { console.error("appendMessage: chatWindow 요소를 찾을 수 없습니다."); }
        }

        // --- ⭐ 알림 함수 분리 (저널 저장 / 분석 완료) ⭐ ---
        function showJournalSavedNotification(journalId) {
            if (journalSaveNotificationShown) return; // 이미 알림이 떴으면 중복 방지 (선택적)
            const notification = document.createElement('div');
            notification.className = 'journal-save-notification'; // CSS 클래스 적용
            notification.textContent = '✅ 세션 이야기 저장 완료! (클릭해서 확인)'; 
            notification.onclick = () => { 
                // journal.html로 이동 시 필요한 정보 전달 (예: localStorage 사용)
                // 이전에 저장된 lozee_conversation_analysis는 가장 최근 "분석" 결과이므로,
                // 저널 상세는 Firestore에서 직접 가져오는 것이 좋음.
                // 여기서는 단순히 journal.html로 journalId만 넘김.
                window.location.href = `journal.html?journalId=${journalId}`; 
            };
            if(chatWindow) chatWindow.appendChild(notification);
            journalSaveNotificationShown = true; // 현재 세션에서 저널 저장 알림 한 번만
        }
               
        function showAnalysisNotification() { // 기존 showAnalysis() 이름 변경
            if (analysisNotificationShown) return;
            const notification = document.createElement('div');
            notification.className = 'analysis-notification'; // 기존 스타일 사용
            notification.textContent = '📊 분석 완료! (클릭해서 확인)'; 
            notification.onclick = () => { location.href = 'analysis.html'; };
            if(chatWindow) chatWindow.appendChild(notification);
            analysisNotificationShown = true; 
        }


        // --- TTS 제어 재생 함수 ---
        async function playTTSWithControl(txt) {
            if (isRec && recog && typeof recog.stop === 'function') { 
                 console.log("TTS 재생 전 STT 명시적 중지"); recog.stop(); 
            }
            if (typeof stopCurrentTTS === 'function') stopCurrentTTS();
            else console.warn("stopCurrentTTS 함수를 찾을 수 없습니다.");
            if (skipTTS) { skipTTS = false; return Promise.resolve(); }
            isPlayingTTS = true;
            try {
                if (typeof playTTSFromText === 'function') {
                    await playTTSFromText(txt, localStorage.getItem('lozee_voice'));
                } else { console.warn("playTTSFromText 함수를 찾을 수 없습니다.");}
            } catch (error) { console.error("playTTSWithControl 내 TTS 재생 오류:", error); } 
            finally { isPlayingTTS = false; }
        }

        // --- 오디오 분석 관련 ---
        let audioContext, analyser, source, dataArray, animId, streamRef;
        const LOW_COLOR = { r:0, g:200, b:0 }; const MID_COLOR = { r:255, g:200, b:0 }; const HIGH_COLOR = { r:255, g:69, b:0 };
        function interp(c1, c2, f) { return `rgb(${Math.round(c1.r + f * (c2.r - c1.r))},${Math.round(c1.g + f * (c2.g - c1.g))},${Math.round(c1.b + f * (c2.b - c1.b))})`;}
        function setupAudioAnalysis(stream) { if (audioContext && audioContext.state !== 'closed') {audioContext.close().catch(e=>console.warn("이전 AudioContext 닫기 오류:", e));} audioContext = new AudioContext(); analyser = audioContext.createAnalyser(); analyser.fftSize = 256; source = audioContext.createMediaStreamSource(stream); source.connect(analyser); dataArray = new Uint8Array(analyser.frequencyBinCount); streamRef = stream; draw(); }
        function draw() { animId = requestAnimationFrame(draw); if (!analyser || !dataArray) return; analyser.getByteFrequencyData(dataArray); let sum = dataArray.reduce((a, v) => a + v, 0); let avg = dataArray.length > 0 ? sum / dataArray.length : 0; let norm = Math.min(100, Math.max(0, (avg / 140) * 100)); if(meterLevel) {meterLevel.style.width = norm + '%'; meterLevel.style.background = `linear-gradient(to right, var(--background-color), ${norm <= 50 ? interp(LOW_COLOR, MID_COLOR, norm / 50) : interp(MID_COLOR, HIGH_COLOR, (norm - 50) / 50)})`;} if (norm > 10 && isRec && isPlayingTTS && !skipTTS) { console.log("사용자 음성 감지, TTS 중단 시도"); if (typeof stopCurrentTTS === 'function') stopCurrentTTS(); skipTTS = true; } }
        function stopAudio() { if (animId) cancelAnimationFrame(animId); if (source) source.disconnect(); if (streamRef) streamRef.getTracks().forEach(track => track.stop()); if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(e=>console.warn("AudioContext 닫기 오류:", e)); } audioContext = null; if(meterLevel) { meterLevel.style.width = '0%'; meterLevel.style.background = getComputedStyle(document.documentElement).getPropertyValue('--volume-meter-container-bg'); } }

        // --- STT (Web Speech API) ---
        const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recog, isRec = false;
        if (SpeechRecognitionAPI) {
            recog = new SpeechRecognitionAPI(); 
            recog.continuous = true; 
            recog.interimResults = true; 
            recog.lang = 'ko-KR';
            recog.onstart = () => { isRec = true; if(micButton) micButton.classList.add('recording'); };
            recog.onend = () => { isRec = false; if(micButton) micButton.classList.remove('recording'); stopAudio(); };
            recog.onresult = event => { 
                resetSessionTimeout(); 
                let interim_transcript = ''; let final_transcript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) { final_transcript += event.results[i][0].transcript; } 
                    else { interim_transcript += event.results[i][0].transcript; }
                }
                if (chatInput && interim_transcript && !final_transcript && document.activeElement === chatInput) {
                    // 사용자가 직접 타이핑 중이 아닐 때만 중간 결과 표시 (선택적 강화)
                    // chatInput.value = interim_transcript; 
                }
                if (final_transcript) { 
                    console.log("STT 최종 결과:", final_transcript); 
                    if(chatInput) chatInput.value = ''; 
                    sendMessage(final_transcript.trim(), 'stt'); 
                } 
            };
            recog.onerror = event => { console.error('Speech recognition error:', event.error); appendMessage('음성 인식 오류: ' + event.error, 'assistant_feedback'); if(isRec && recog){ try{recog.stop();}catch(e){console.warn("recog.stop() 오류:",e)}} isRec = false; if(micButton) micButton.classList.remove('recording'); stopAudio(); };
            
            // gpt 마이크 버튼 눌렀을 시 언제나 TTS 재생을 바뀌도록 20250531 오후 8시 30분 수정 
                  if (micButton) micButton.onclick = async () => {
           // ───────────────────────────────────
           // 1) “마이크가 꺼져 있던(isRec===false) 상태라면 → TTS 먼저 재생”
           if (!isRec) {
               // (1) 최신 assistant 메시지를 가져와서 TTS로 재생
               //    chatHistory 배열에서 role === 'assistant'인 마지막 요소를 찾는다
               const lastAssistant = [...chatHistory].reverse().find(m => m.role === 'assistant');
               if (lastAssistant) {
                   try {
                       // 재생 중단 플래그 초기화
                       skipTTS = false;
                       await playTTSWithControl(lastAssistant.content);
                   } catch (ttsError) {
                       console.error("마이크 누름 시 TTS 재생 오류:", ttsError);
                   }
               }

               // (2) TTS가 끝난 뒤에 STT 모드로 진입
               try {
                   if (typeof stopCurrentTTS === 'function') stopCurrentTTS();
                   // TTS를 명시적으로 멈추고 skipTTS 재설정(이미 재생이 끝났으므로)
                   skipTTS = true;
                   const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                   setupAudioAnalysis(stream);
                   if (recog) recog.start();
               } catch (e) {
                   console.error('마이크 접근 오류:', e);
                   appendMessage('마이크 사용 권한이 필요합니다.', 'assistant_feedback');
               }

           } else {
               // ───────────────────────────────────
               // 2) 이미 음성 인식 중(isRec===true)이라면 → 그냥 음성 인식 종료
               if (recog) recog.stop();
          }
       };
      // ───────────────────────────────────
 

        } else { 
            if(micButton) micButton.disabled = true; 
            appendMessage('이 브라우저에서는 음성 인식을 지원하지 않습니다.', 'assistant_feedback'); 
        }


        // --- ⭐ 마이크 버튼 클릭 로직 수정 (중복 방지) ⭐ ---
        if(micButton) {
            micButton.onclick = async () => {
                if (isMicProcessing) { // 이미 마이크 처리 중이면
                    appendMessage("로지의 답변을 기다리고 있어요... 조금만 기다려주세요! 😊", "assistant_feedback");
                    return;
                }
                isMicProcessing = true; // 처리 시작 플래그

                if (isRec) { // STT 중이면 종료
                    if(recog) recog.stop(); 
                    isMicProcessing = false; // 처리 완료
                } else { // STT 시작 전
                    if (typeof stopCurrentTTS === 'function') stopCurrentTTS(); 
                    skipTTS = true;   
                    try { 
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); 
                        setupAudioAnalysis(stream); 
                        if(recog) recog.start(); 
                    } catch (e) { 
                        console.error('마이크 접근 오류:', e); 
                        appendMessage('마이크 사용 권한이 필요합니다.', 'assistant_feedback'); 
                        isMicProcessing = false; // 오류 시 플래그 해제
                    }
                    // STT 시작 후 isMicProcessing은 STT onstart/onend에서 관리하거나,
                    // STT 결과 처리 후 sendMessage에서 isProcessing이 false가 될 때 함께 false로 설정
                    // 여기서는 STT 시작 요청 후 일단 false로 두어, STT 오류 시 다시 누를 수 있도록 함 (단, STT가 바로 시작 안 되면 문제 가능)
                    // 더 나은 방법은 STT onstart에서 isMicProcessing을 true로, onend/onerror에서 false로 하는 것
                    // 현재 STT onstart에서 isRec=true; micButton.classList.add('recording'); 하므로,
                    // isRec 상태를 isMicProcessing 대신 사용해도 유사하게 동작 가능
                    // 여기서는 일단 isMicProcessing을 빠르게 false로 돌려 여러 번 누르는 것 자체를 막기보다는,
                    // 답변 대기 중이라는 메시지를 보여주는 것에 초점
                    setTimeout(() => { isMicProcessing = false; }, 1000); // 1초 후 다시 누를 수 있도록 (임시)
                } 
            };
        } else { console.error("micButton 요소를 찾을 수 없습니다."); }


        // --- 토픽 플로우 ---
 function getTopicsForCurrentUser() {
            // const userType = localStorage.getItem('lozee_userType'); // 이미 전역으로 선언됨
            // ⭐ 보호자 유형일 때도 '본인 나이(userAge)'를 기준으로 counselingTopicsByAge.caregiver 조회
            const ageForTopicLookup = userAge; // 아이 나이가 아닌 보호자 본인 나이 사용
            
            console.log(`getTopicsForCurrentUser - userType: ${userType}, ageForTopicLookup (보호자본인나이 또는 당사자나이): ${ageForTopicLookup}`);

            if (!counselingTopicsByAge) { 
                console.error("counselingTopicsByAge 객체를 찾을 수 없습니다. (counseling_topics.js 확인 필요)"); 
                return {}; 
            }

            let topicsForUserGroup;
            if (userType === 'directUser' && counselingTopicsByAge.directUser) {
                if (ageForTopicLookup < 11) topicsForUserGroup = counselingTopicsByAge.directUser['10세미만'];
                else if (ageForTopicLookup >= 11 && ageForTopicLookup <= 15) topicsForUserGroup = counselingTopicsByAge.directUser['11-15세'];
                else if (ageForTopicLookup >= 16 && ageForTopicLookup <= 29) topicsForUserGroup = counselingTopicsByAge.directUser['16-29세'];
                else topicsForUserGroup = counselingTopicsByAge.directUser['30-55세'] || counselingTopicsByAge.directUser['16-29세']; // 30-55세 또는 기본값
            } else if (userType === 'caregiver' && counselingTopicsByAge.caregiver) {
                // 보호자 주제는 연령 구분 없이 caregiver 공통 주제 사용 또는 필요시 연령대 추가
                topicsForUserGroup = counselingTopicsByAge.caregiver; 
            } else {
                console.warn(`알 수 없거나 지원하지 않는 사용자 유형(${userType})입니다. 기본 주제를 사용합니다.`);
                topicsForUserGroup = counselingTopicsByAge.directUser ? (counselingTopicsByAge.directUser['11-15세'] || {}) : {};
            }
            
            if (!topicsForUserGroup || Object.keys(topicsForUserGroup).length === 0) {
                console.warn(`선택된 사용자 유형/나이에 맞는 주제 카테고리가 counseling_topics.js에 정의되지 않았거나 비어있습니다.`);
                return {};
            }
            console.log("선택된 사용자/나이 그룹 주제:", topicsForUserGroup);
            return topicsForUserGroup;
        }
                
        function displayOptionsInChat(optionsArray, onSelectCallback) { 
            if (!chatWindow) { 
                console.error("displayOptionsInChat: chatWindow 요소를 찾을 수 없습니다."); return; }
            const optionsContainer = document.createElement('div'); 
            optionsContainer.className = 'chat-options-container'; 
            const buttons = []; 
            if (!optionsArray || !Array.isArray(optionsArray)) { console.error("displayOptionsInChat: optionsArray가 유효한 배열이 아닙니다."); 
            return; }
            optionsArray.forEach(optionObject => { 
                let buttonText; let valueToCallback; 
                if (typeof optionObject === 'string') { 
                    buttonText = optionObject; valueToCallback = optionObject;} 
                else if (optionObject && typeof optionObject.displayText !== 'undefined') { 
                    buttonText = optionObject.icon ? `${optionObject.icon} ${optionObject.displayText}` : 
                    optionObject.displayText; valueToCallback = optionObject.displayText; 
                } else { console.warn("displayOptionsInChat: 잘못된 형식의 옵션:", 
                optionObject); 
                return; 
            } 

                const button = document.createElement('button');
                button.className = 'chat-option-btn'; 
                button.textContent = buttonText; 
                if (optionObject && optionObject.isContinuation) { button.classList.add('continue-topic-btn'); }
                if (optionObject && optionObject.isManualSave) { button.classList.add('manual-save-btn');
        }
                
                button.onclick = () => { 
                    buttons.forEach(btn => { 
                        btn.disabled = true; 
                        if (btn === button) { 
                            btn.classList.add('selected'); 
                        } 
                    }); 
                        onSelectCallback(valueToCallback); 
                    }; 
                optionsContainer.appendChild(button); 
                buttons.push(button); 
            }); 
            chatWindow.appendChild(optionsContainer); 
            chatWindow.scrollTop = chatWindow.scrollHeight; 
        }

        function showMainTopics() { 
            console.log("showMainTopics 함수 시작됨"); 
            appendMessage('어떤 이야기를 나눠볼까?', 'assistant'); 
            const currentUserTopics = getTopicsForCurrentUser(); 
            let topicsWithOptions = []; 

            // "mypage (로지와의 약속)"에서 넘어온 이어하기 주제 (타입: 'cognitive_distortion_follow_up' 등)
            const continueTopicDataFromPlans = localStorage.getItem('lozee_continue_topic');
            if (continueTopicDataFromPlans) { 
                try { 
                    const topicToContinue = JSON.parse(continueTopicDataFromPlans); 
                    topicsWithOptions.push({ 
                        icon: '↪️', 
                        displayText: `[약속] ${topicToContinue.details || '이전 생각 이어가기'}`, 
                        isContinuation: true, 
                        continueDetails: topicToContinue,
                        type: 'mypage_plan' 
                    }); 
                } catch (e) { console.error("로지와의 약속 파싱 오류:", e); localStorage.removeItem('lozee_continue_topic');} 
            }
            
            // 일반 주제들 추가
            if (currentUserTopics && typeof currentUserTopics === 'object' && Object.keys(currentUserTopics).length > 0) { /* ... */ } 
            topicsWithOptions.push({ icon: '🗣️', displayText: '자유주제', isContinuation: false }); 
            
            displayOptionsInChat(topicsWithOptions, (selectedText, fullOptionObject) => { 
                // ⭐ selectedMain 설정은 여기서 이루어짐 (사용자가 버튼 클릭 시)
                selectedMain = selectedText; 
                
                if (fullOptionObject && fullOptionObject.isContinuation) { // "이어하기" 버튼 클릭 시
                    localStorage.removeItem('lozee_continue_topic'); 
                    selectedMain = fullOptionObject.continueDetails.details || selectedText; // 실제 주제명으로 selectedMain 업데이트
                    appendMessage(selectedMain + ' 이야기를 이어갈게!', 'assistant');
                    const continueMessage = fullOptionObject.continueDetails && fullOptionObject.continueDetails.details 
                        ? `저번에 이야기했던 '${selectedMain}'에 대해 계속 이야기해보자.` 
                        : "저번에 나누던 이야기, 계속해볼까?";
                    startChat(continueMessage, 'topic_selection_init'); 
                } else if (selectedMain === '자유주제') { 
                    appendMessage(selectedMain + ' 이야기를 선택했구나!', 'assistant'); 
                    const message = '네가 정하면 돼. 어떤 이야기가 하고 싶어?'; 
                    appendMessage(message, 'assistant'); 
                    if(inputArea) inputArea.style.display = 'flex'; if(chatInput) chatInput.focus();  
                } else { // 일반 주제 카테고리 선택 시
                    appendMessage(selectedMain + ' 이야기를 선택했구나!', 'assistant'); 
                    setTimeout(showSubTopics, 300); 
                } 
            }); 
        }
           
        function showSubTopics() { 
            if (!selectedMain) { console.warn("showSubTopics: selectedMain이 설정되지 않음"); return; } 
            const currentUserTopicCategories = getTopicsForCurrentUser(); let subtopicOptions = [];
            if (selectedMain === '자유주제') { startChat('', 'topic_selection_init'); return; } 
            else if (currentUserTopicCategories && currentUserTopicCategories[selectedMain] && Array.isArray(currentUserTopicCategories[selectedMain])) { subtopicOptions = currentUserTopicCategories[selectedMain]; } 
            else { console.warn(`'${selectedMain}' 카테고리에 대한 하위 주제를 찾을 수 없거나 형식이 잘못되었습니다.`); subtopicOptions = [{ icon: '💬', displayText: '이 주제에 대해 자유롭게 이야기해 줄래?' }]; } 
            if (!subtopicOptions || subtopicOptions.length === 0) { console.log(`'${selectedMain}' 카테고리에 하위 주제가 없습니다.`); startChat(`'${selectedMain}'에 대해 자유롭게 이야기해줘.`, 'topic_selection_init'); return; } 
            appendMessage('조금 더 구체적으로 이야기해 줄래?', 'assistant');
            displayOptionsInChat(subtopicOptions, (selectedSubtopicText) => { startChat(selectedSubtopicText, 'topic_selection_init'); }); 
        }

               function startChat(initText, inputMethod = 'topic_selection_init') { 
            console.log("startChat 함수 시작됨, 초기 메시지:", initText, "입력방식:", inputMethod, "현재 selectedMain:", selectedMain); 
            // if (topicArea && typeof topicArea.style !== 'undefined') topicArea.style.display = 'none !important'; 
            if (inputArea) inputArea.style.display = 'flex'; 
            
            // ⭐ 세션 시작 로그는 여기서, selectedMain이 확정된 후에, 그리고 새 세션일 때만
            if(currentUserEmail && selectedMain && !currentFirestoreSessionId && typeof logSessionStart === 'function'){ 
                logSessionStart(currentUserEmail, selectedMain).then(id => {
                    if (id) currentFirestoreSessionId = id;
                    console.log("새로운 세션 시작, 주제:", selectedMain, "세션 ID:", currentFirestoreSessionId);
                });
            }
            if (initText && String(initText).trim() !== '') { 
                sendMessage(initText, inputMethod); 
            } else { 
                if (chatInput) chatInput.focus(); 
            }
        }   
         
        
        // --- 말 길이 선호도 질문 함수 ---
        function askForVerbosityPreference() {
            if (verbosityPromptCount >= 2) return; 
            const options = [ { displayText: "말을 좀 줄여줘" }, { displayText: "지금이 적당해" }, { displayText: "나에게 더 많은 조언을 줘" } ];
            appendMessage("지금 내가 하는 말이 너에게 적당한지 알려줄래?", 'assistant');
            displayOptionsInChat(options, (selectedOption) => {
                appendMessage(selectedOption, 'user'); 
                if (selectedOption === "말을 좀 줄여줘") gptVerbosityPreference = 'short';
                else if (selectedOption === "나에게 더 많은 조언을 줘") gptVerbosityPreference = 'verbose';
                else gptVerbosityPreference = 'default';
                verbosityPromptCount++; lastVerbosityPromptTime = Date.now(); 
                const followupMessage = "알려줘서 고마워! 이 설정은 약 10분간 유지될 거야. 계속해서 하고 싶은 이야기를 해줘.";
                appendMessage(followupMessage, 'assistant');
            });
        }
        
        // --- ⭐ 세션 타임아웃 및 저널/통계 저장 로직 수정 ⭐ ---
        function resetSessionTimeout() {
            if (sessionTimeoutId) clearTimeout(sessionTimeoutId);
            sessionTimeoutId = setTimeout(async () => {
                console.log("5분 이상 대화 없음. 세션 종료 및 저널/통계 저장 시도.");
                if (currentUserEmail && selectedMain && chatHistory.length > 1) { 
                    const sessionDurationForJournal = Math.round((Date.now() - conversationStartTime) / (1000 * 60));
                    const currentJournalPayload = { 
                        ...(lastAiAnalysisData || {}), 
                        sessionDurationMinutes: sessionDurationForJournal,
                        userCharCountForThisSession: userCharCountInSession 
                    };
                    
                    let savedJournalId = null;
                    if (typeof saveJournalEntry === 'function') {
                        savedJournalId = await saveJournalEntry(currentUserEmail, selectedMain, chatHistory, currentJournalPayload);
                        if (savedJournalId) {
                            // 저널 저장 성공 시 알림은 여기서 하지 않고, 아래 글자 수 기반으로만.
                            // 또는, 여기서 "대화가 마무리되어 저장되었어요" 같은 일반적인 메시지 가능
                        }
                    }
                    if (typeof updateTopicStats === 'function') { await updateTopicStats(currentUserEmail, selectedMain); }
                    
                    // users 컬렉션 업데이트 (totalUserCharCount, session count)
                    const finalTotalUserCharsToSave = previousTotalUserCharCountOverall + userCharCountInSession;
                    try {
                        const userRef = doc(db, 'users', currentUserEmail);
                        const userSnap = await getDoc(userRef);
                        let updates = { totalUserCharCount: finalTotalUserCharsToSave, lastLogin: serverTimestamp() };
                        if (userSnap.exists()) {
                            const userData = userSnap.data();
                            if (userType === 'directUser') {
                                updates.totalSessionCount = (userData.totalSessionCount || (userData.directUser ? userData.directUser.totalSessionCount : 0) || 0) + 1;
                            } else if (userType === 'caregiver') {
                                updates.childTotalSessionCount = (userData.childTotalSessionCount || (userData.caregiver ? userData.caregiver.childTotalSessionCount : 0) || 0) + 1;
                            }
                        } else { /* ... (신규 사용자 처리 - index.html에서 이미 함) ... */ }
                        await setDoc(userRef, updates, { merge: true });
                        previousTotalUserCharCountOverall = finalTotalUserCharsToSave; 
                    } catch (error) { console.error("Firestore 사용자 문서 업데이트 오류:", error); }
                    
                    // 세션 관련 상태 초기화
                    chatHistory = []; lastAiAnalysisData = null; 
                    userTurnCountInSession = 0; userCharCountInSession = 0; 
                    analysisNotificationShown = false; journalSaveNotificationShown = false; // 알림 플래그 리셋
                    assistantMessageCount = 0; verbosityPromptCount = 0;
                    conversationStartTime = Date.now(); 
                    // currentFirestoreSessionId = null; // logSessionStart/End 사용 시

                    appendMessage("긴 시간 대화가 없어서 이번 이야기는 마무리하고 저장했어! 언제든 다시 이야기하고 싶으면 새로운 주제를 선택하거나 말을 걸어줘. 😊", "assistant_feedback");
                    if(inputArea) inputArea.style.display = 'none'; 
                    showMainTopics(); 
                } else { 
                    console.log("저장할 대화 내용이 없거나 필수 정보 부족. 타임아웃 리셋.");
                    resetSessionTimeout(); 
                }
            }, SESSION_TIMEOUT_DURATION);
        }

        // --- ⭐ 메시지 전송 함수 (저널/분석 알림 로직 수정) ⭐ ---
        async function sendMessage(text, inputMethod = 'text') { 
            if (!selectedMain && inputMethod !== 'topic_selection_init' && text.trim() !== '') {
                appendMessage("이야기를 시작하기 전에 먼저 어떤 주제로 이야기할지 선택해 줄래? 😊", "assistant_feedback");
                showMainTopics(); // 주제 선택창 다시 표시
                isProcessing = false; if(sendBtn) sendBtn.classList.remove('loading');
                return;
            }
            if (!text || String(text).trim() === '' || isProcessing) return;
            resetSessionTimeout(); 
            isProcessing = true;
            if(sendBtn) sendBtn.classList.add('loading');

            if (!conversationStartTime) conversationStartTime = Date.now();

            if (inputMethod !== 'topic_selection_init') { 
                appendMessage(text, 'user');
                userTurnCountInSession++; 
            }
            chatHistory.push({ role: 'user', content: text }); 
            if (inputMethod !== 'topic_selection_init') {
                 userCharCountInSession += text.length; 
            }

            if (chatInput) chatInput.value = '';
            const thinkingBubble = document.createElement('div'); /* ... */ 
            if (chatWindow) { /* ... */ }
            
            try {
                const elapsedTimeInMinutesForGPT = (Date.now() - conversationStartTime) / (1000 * 60);
                const userDiagnoses = JSON.parse(localStorage.getItem('lozee_diagnoses') || '[]');

                const res = await getGptResponse(text, { chatHistory, verbosity: gptVerbosityPreference, elapsedTime: elapsedTimeInMinutesForGPT, userTraits: userDiagnoses }); 
                if (thinkingBubble) thinkingBubble.remove(); 
                if (!res.ok) {
                    const errorData = await res.text();
                    console.error(`GPT API 응답 오류 ${res.status}: ${errorData}`);
                    appendMessage("미안, 지금은 답변하기 조금 어려워. (서버 응답 오류)", "assistant_feedback");
                    return; // finally는 실행됨
                }
                const d = await res.json();
                
                let cleanText = ""; let analysisDataFromGpt = {};
                if (d.text && typeof d.text === 'string') {
                    const jsonStartIndex = d.text.lastIndexOf('{"sentiment":');
                    cleanText = jsonStartIndex !== -1 ? d.text.slice(0, jsonStartIndex).trim() : d.text.trim();
                    const analysisJsonString = jsonStartIndex !== -1 ? d.text.slice(jsonStartIndex) : null;
                    if (analysisJsonString) {
                        try { analysisDataFromGpt = JSON.parse(analysisJsonString); } 
                        catch (e) { console.error("GPT 분석 JSON 파싱 오류:", e); }
                    }
                }
                lastAiAnalysisData = analysisDataFromGpt; // GPT 분석 결과 저장
                    
                appendMessage(cleanText, 'assistant'); 


                chatHistory.push({ role: 'assistant', content: cleanText });
                assistantMessageCount++; 
                    
                // --- AI 응답 말풍선 표시 ---
                appendMessage(clean, 'assistant');


                // --- ⭐ 저널 저장 알림 (800자 기준) ⭐ ---
                if (userCharCountInSession >= 800 && !journalSaveNotificationShown && selectedMain) {
                    // 이 시점에 즉시 저장하고 journalId를 받아올 수도 있지만,
                    // 일단은 "저장 준비 완료" 알림만 띄우고 실제 저장은 세션 종료 시에.
                    // 또는, 여기서 바로 임시 저장 후 ID를 받아 notification에 연결할 수도 있음.
                    // 현재는 알림만 띄우고, 실제 저장은 타임아웃 로직에서 함.
                    const tempJournalDataForNotification = { 
                        ...(lastAiAnalysisData || {}), 
                        sessionDurationMinutes: Math.round((Date.now() - conversationStartTime) / (1000 * 60)),
                        userCharCountForThisSession: userCharCountInSession 
                    };
                    // 임시로 저널을 저장하고 ID를 받아와서 알림에 연결하는 것이 더 사용자 친화적일 수 있음
                    // 여기서는 간단히 알림만 먼저 표시 (실제 저장은 타임아웃 시)
                    // 만약 즉시 저장하고 ID를 받아오려면:
                    // const savedJournalId = await saveJournalEntry(currentUserEmail, selectedMain, chatHistory, tempJournalDataForNotification);
                    // if (savedJournalId) showJournalSavedNotification(savedJournalId);
                    
                    // 지금은 "곧 저장될거야" 라는 느낌으로 알림만.
                    const journalNotif = document.createElement('div');
                    journalNotif.className = 'journal-save-notification';
                    journalNotif.textContent = `📝 이야기가 충분히 쌓였네! 대화가 끝나면 자동으로 저장될 거야.`;
                    if(chatWindow) chatWindow.appendChild(journalNotif);
                    journalSaveNotificationShown = true; // 한 세션에 한 번만
                }


// ─── “방법을 알려줄까?” 문구가 포함된 경우에만 선택박스 띄우기 ─────────────────
        if (clean.includes("방법을 알려줄까")) {
          // 다음 Assistant 응답을 저장 대기 상태로 설정
          awaitManualSave = false;      // 아직 “방법을 알려줘.” 선택 전이므로 false
          manualSaveConfirmed = false;

          // 2가지 선택 버튼: “방법을 알려줘.”, “알려주지 않아도 돼.”
          const optionsForManual = [
            { displayText: "방법을 알려줘." },
            { displayText: "알려주지 않아도 돼." }
          ];
          displayOptionsInChat(optionsForManual, async (selectedOption) => {
            appendMessage(selectedOption, 'user');
            if (selectedOption === "방법을 알려줘.") {
              // “방법을 알려줘.” 선택 → 다음 Assistant 응답을 저장 대기
              awaitManualSave = true;
              manualSaveConfirmed = true;
              // AI가 실제로 “방법”을 설명 이어서 보내도록 별도 호출할 수 있음
              // 예: sendMessage("방법을 설명해줘.", 'text');
      
              // ─── “awaitManualSave && manualSaveConfirmed”이 true인 상태에서 (다음번에 오는) Assistant 답변을 자동 저장 ───
               if (awaitManualSave && manualSaveConfirmed) {
            try {
                const userId = localStorage.getItem('cbtUserEmail');
                const currentTopic = selectedMain || "수동 저장"; // selectedMain이 없을 경우 기본값
                // const contentToSave = clean; // AI의 현재 응답(clean)을 저장
                
                // 만약 "방법을 알려줘"에 대한 AI의 이전 턴 응답을 저장하고 싶다면,
                // chatHistory에서 해당 응답을 찾아야 합니다.
                // 여기서는 현재 AI 응답(clean)을 저장한다고 가정합니다.
                if (clean) { // 저장할 내용이 있을 때만
                    await saveManualJournalEntry(userId, currentTopic, clean); // clean: AI의 "방법 설명" 내용
                    appendMessage("✅ 로지의 설명을 이야기로 잘 저장했어!", 'assistant_feedback');
                }
            } catch (err) {
                console.error("수동 저장 오류 (sendMessage 내):", err);
                appendMessage("⚠️ 저장이 잘 안 된 것 같아. 다시 시도해 줄래?", 'assistant_feedback');
            } finally {
                awaitManualSave = false; // 플래그 리셋
                manualSaveConfirmed = false;
            }
        }

            } else {
              // “알려주지 않아도 돼.” 선택 → 저장 프로세스 취소
              awaitManualSave = false;
              manualSaveConfirmed = false;
              appendMessage("알겠어, 저장하지 않을게!", 'assistant');
            }
          });
        }



                // ───────── 수정된 부분 ─────────
                // skipTTS가 false인 경우에는 어떤 입력 방식(text, topic_selection_init, stt)이든
                // 무조건 TTS 재생을 시도하도록 변경

                
        // ─────────── 수정된 TTS 로직 ───────────
        // 1) 기존 재생 중인 TTS가 있다면 중단
        if (typeof stopCurrentTTS === 'function') {
            stopCurrentTTS();
        }
        // 2) 이 턴에서 TTS를 재생하라는 플래그가 세트되어 있으면, playTTSWithControl 호출
        //    단, 이미 skipTTS가 true라면(예: 마이크 누른 직후 STT 모드라면) 재생을 건너뜀
        if (!skipTTS) {
            try {
                isPlayingTTS = true;        // 내부적으로 TTS 재생 중 상태 표시
                await playTTSWithControl(clean);
            } catch (e) {
                console.error("playTTSWithControl 오류:", e);
            } finally {
                isPlayingTTS = false;
            }
        }
        // 3) 한 번 재생했거나 재생을 건너뛴 뒤에는 반드시 다음 턴을 위해 skipTTS 초기화
        skipTTS = false;
        // ─────────────────────────────────────

        chatHistory.push({ role: 'assistant', content: clean });
        assistantMessageCount++;

                
                // 분석 알림 로직 (수정된 조건)
                  const currentSessionElapsedTime = (Date.now() - conversationStartTime) / (1000 * 60);
                const finalUserCharCountForAnalysis = previousTotalUserCharCountOverall + userCharCountInSession;
                console.log(`[분석 조건 체크] 시간: ${currentSessionElapsedTime.toFixed(1)}분 (기준:10), 사용자 턴: ${userTurnCountInSession} (기준:20), 총 글자수: ${finalUserCharCountForAnalysis} (기준:1500)`);
                if (currentSessionElapsedTime >= 10 && userTurnCountInSession >= 20 && finalUserCharCountForAnalysis >= 1500 && !analysisNotificationShown) { 
                    console.log(`[분석 조건 충족!] 상세 분석 실행 및 localStorage 저장`);
                    let detailedAnalysisDataForStorage = { ...(lastAiAnalysisData || {}) }; 
                    if (LOZEE_ANALYSIS && typeof LOZEE_ANALYSIS.inferAgeAndLanguage === 'function') { /* ... */ }
                    // 다른 분석 모듈 호출
                    if(Object.keys(detailedAnalysisDataForStorage).length > 0) {
                        localStorage.setItem('lozee_conversation_analysis', JSON.stringify({
                            startTime: conversationStartTime, 
                            analysisTime: Date.now(),
                            accumulatedDurationMinutes: Math.round(currentSessionElapsedTime), 
                            accumulatedUserCharCount: finalUserCharCountForAnalysis, 
                            results: detailedAnalysisDataForStorage
                        }));

                       showAnalysisNotification(); // ⭐ 이름 변경된 함수 호출
                        analysisNotificationShown = true;
                    } else { console.log("생성된 분석 데이터가 없어 알림 표시 안 함."); }
                } else if (!analysisNotificationShown) { console.log("[분석 조건 미충족]"); }

                if (verbosityPromptCount === 0 && assistantMessageCount >= 5) { askForVerbosityPreference(); } 
                else if (verbosityPromptCount === 1 && (Date.now() - lastVerbosityPromptTime > PREFERENCE_PROMPT_INTERVAL)) { askForVerbosityPreference(); }

                 // --- ⭐ 수동 저장 로직 (이전 답변 내용 참고하여 추가) ⭐ ---
                if (cleanText.includes("방법을 알려줄까") && typeof displayOptionsInChat === 'function') { // AI가 제안 시
                    awaitManualSave = true; // 이 플래그는 다음 사용자 입력에서 "방법을 알려줘"를 선택했는지 판단하는데 사용될 수 있음
                    manualSaveConfirmed = false;
                    const optionsForManual = [ { displayText: "응, 방법을 알려줘! (저장하기)", isManualSave: true }, { displayText: "괜찮아, 저장 안 할래." } ];
                    displayOptionsInChat(optionsForManual, async (selectedOption) => {
                        appendMessage(selectedOption, 'user');
                        if (selectedOption === "응, 방법을 알려줘! (저장하기)") {
                            manualSaveConfirmed = true; // 사용자가 저장을 확정
                            // AI에게 실제로 방법 설명을 요청하거나, 다음 AI 응답을 저장하도록 플래그 설정
                            // 여기서는 다음 AI의 응답(방법 설명)을 기다렸다가 그 내용을 저장해야 함
                            appendMessage("좋아! 로지가 방법을 설명해주면 그 내용을 따로 저장해둘게.", "assistant_feedback");
                        } else {
                            awaitManualSave = false;
                            manualSaveConfirmed = false;
                            appendMessage("알겠어, 그럼 이야기 계속할까?", 'assistant');
                        }
                    });
                } else if (awaitManualSave && manualSaveConfirmed) { // 사용자가 "방법을 알려줘"를 선택한 후 AI가 설명을 한 경우
                    try {
                        if (cleanText && typeof saveManualJournalEntry === 'function') { // AI의 설명 내용(cleanText)이 있을 때
                            const savedManualId = await saveManualJournalEntry(currentUserEmail, selectedMain || "로지 설명", cleanText);
                            if (savedManualId) {
                                appendMessage("✅ 로지의 설명을 이야기로 잘 저장했어!", 'assistant_feedback');
                            }
                        }
                    } catch (err) { console.error("수동 저장 오류:", err); appendMessage("⚠️ 저장 실패.", 'assistant_feedback');}
                    finally { awaitManualSave = false; manualSaveConfirmed = false; } // 플래그 리셋
                }
                
                              
                
                
                // gpt 수정 버젼 05-31 오후 8시 30분 수정 
              } catch (error) {
         if (thinkingBubble) thinkingBubble.remove();
         console.error("sendMessage 내 오류:", error);
         appendMessage("미안, 지금은 답변하기 조금 어려워. 잠시 후 다시 시도해 줄래?", "assistant_feedback");
     } finally {
         isProcessing = false;
         if (sendBtn) sendBtn.classList.remove('loading');
     }
 }

        // --- 이벤트 바인딩 ---
if(sendBtn) sendBtn.addEventListener('click', () => { resetSessionTimeout(); sendMessage(chatInput.value, 'text'); }); 
        else console.error("sendBtn 요소를 찾을 수 없습니다.");
        if(chatInput) chatInput.addEventListener('keydown', e => { 
            resetSessionTimeout(); 
            if (isPlayingTTS) { if (typeof stopCurrentTTS === 'function') stopCurrentTTS(); skipTTS = true; }
            if (e.key === 'Enter' && !e.isComposing) { e.preventDefault(); sendMessage(chatInput.value, 'text'); }
        });
        else console.error("chatInput 요소를 찾을 수 없습니다.");
    </script>
    <script src="./js/gnb.js" defer></script> 
    </body>
</html>